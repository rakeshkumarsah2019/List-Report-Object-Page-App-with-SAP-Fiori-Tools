"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const utils_1 = require("../utils");
const prompts_1 = __importDefault(require("prompts"));
const yeoman_environment_1 = __importDefault(require("yeoman-environment"));
const constants_1 = require("./constants");
const fs = __importStar(require("fs"));
const dotenv_1 = require("dotenv");
/**
 * CLI short option to long name map
 */
const paramMap = {
    '-o': 'object',
    '-a': 'action',
    '-t': 'title',
    '-s': 'subtitle',
    '-f': 'force'
};
function getSupportedTargets() {
    const abap = { name: constants_1.Target.ABAP, description: 'ABAP', handler: handleABAP };
    const cf = { name: constants_1.Target.CLOUD_FOUNDRY, description: 'Cloud Foundry', handler: handleCF };
    const ENABLE_CF_SUPPORT = process.env.ENABLE_CF_SUPPORT;
    if (!ENABLE_CF_SUPPORT) {
        abap.default = true;
        return [abap, cf];
    }
    else {
        const possiblyCloudFoundry = fs.existsSync(path_1.join('..', 'cf', 'mta.yaml')) ||
            fs.existsSync(path_1.join('..', 'mta.yaml')) ||
            fs.existsSync(path_1.join('.', 'cf', 'mta.yaml')) ||
            fs.existsSync(path_1.join('.', 'mta.yaml'));
        return possiblyCloudFoundry ? [cf, abap] : [abap, cf];
    }
}
async function addFlpConfig(args) {
    var _a, _b, _c;
    dotenv_1.config();
    const result = {
        added: true
    };
    const supportedTargets = getSupportedTargets();
    let target = (_a = supportedTargets.find((t) => t.name === args[0])) === null || _a === void 0 ? void 0 : _a.name;
    if (target)
        args = args.slice(1);
    const params = utils_1.parseArgs(args, paramMap);
    if (!target) {
        target = (_b = supportedTargets.find((t) => t.default)) === null || _b === void 0 ? void 0 : _b.name;
        if (!target) {
            const { cancel, target: t } = await promtForTarget(params, supportedTargets);
            if (cancel) {
                console.log('Canceled. Exiting');
                return (result.added = false), result;
            }
            else
                target = t;
        }
    }
    const handler = (_c = supportedTargets.find((t) => t.name === target)) === null || _c === void 0 ? void 0 : _c.handler;
    if (!handler) {
        console.log(`Cannot handle target: [${target}]`);
        return (result.added = false), result;
    }
    else
        return (result.added = await handler(params)), result;
}
exports.addFlpConfig = addFlpConfig;
async function promtForTarget(params, supportedTargets) {
    const result = { cancel: false };
    prompts_1.default.override(params);
    const questions = [
        {
            type: 'select',
            name: 'target',
            choices: supportedTargets.map((t) => {
                return { title: t.description, value: t.name };
            }),
            message: 'Choose target'
        }
    ];
    const onCancel = () => {
        result.cancel = true;
        return false;
    };
    if (questions.length > 0) {
        Object.assign(result, await prompts_1.default(questions, { onCancel }));
    }
    return result;
}
async function handleABAP(params) {
    const { added } = await addCommonConfig(params);
    return added;
}
exports.handleABAP = handleABAP;
async function handleCF(params) {
    try {
        const { added, inboundName } = await addCommonConfig(params);
        if (added)
            generateCFArtifacts(inboundName);
    }
    catch (e) {
        return false;
    }
    return true;
}
function generateCFArtifacts(inboundName) {
    const env = yeoman_environment_1.default.createEnv();
    env.register(require.resolve('@sap/generator-fiori-deployment/generators/flp/index.js'), 'flp-generator');
    return new Promise((resolve, reject) => {
        env.run('flp-generator', { inboundName }, (err) => {
            if (err)
                reject(err);
            else
                resolve();
        });
    });
}
async function addCommonConfig(params) {
    const result = { added: true, inboundName: undefined };
    try {
        const manifestPath = manifestFullPath();
        const manifest = JSON.parse(fs_1.readFileSync(manifestPath).toString());
        const configExists = !!manifest['sap.app'].crossNavigation;
        await promptUserIfRequired(params, configExists);
        if (params.canceled) {
            console.warn('Canceled. Exiting');
            return (result.added = false), result;
        }
        else if (configExists && !params.force) {
            console.log('Choosing not to overwrite existing configuration');
            console.log('Please choose to overwrite at the prompt next time or use option -f to force overwrite');
            return (result.added = false), result;
        }
        const { flpConfig, inboundName } = generateConfig(params);
        manifest['sap.app'].crossNavigation = flpConfig;
        result.inboundName = inboundName;
        fs_1.writeFileSync(manifestPath, JSON.stringify(manifest, null, 4));
        return result;
    }
    catch (e) {
        console.warn(e.message);
        return (result.added = false), result;
    }
}
exports.addCommonConfig = addCommonConfig;
function generateConfig(params) {
    var _a;
    const inboundName = `${params.object}-${params.action}`;
    return {
        flpConfig: {
            inbounds: {
                [inboundName]: {
                    signature: {
                        parameters: {},
                        additionalParameters: 'allowed'
                    },
                    semanticObject: params.object,
                    action: params.action,
                    title: params.title,
                    subTitle: (_a = params.subtitle, (_a !== null && _a !== void 0 ? _a : '')),
                    icon: ''
                }
            }
        },
        inboundName
    };
}
async function promptUserIfRequired(params, configExists) {
    prompts_1.default.override(params);
    const questions = [
        {
            type: () => (configExists ? 'confirm' : false),
            name: 'force',
            message: 'Configuration exists, overwrite?',
            initial: false
        },
        {
            type: 'text',
            name: 'object',
            message: 'Semantic Object',
            format: (val) => { var _a; return (_a = val) === null || _a === void 0 ? void 0 : _a.trim(); },
            validate: (val) => { var _a; return ((_a = val) === null || _a === void 0 ? void 0 : _a.trim().length) === 0 ? 'Semantic Object is required' : true; }
        },
        {
            type: 'text',
            name: 'action',
            message: 'Action',
            format: (val) => { var _a; return (_a = val) === null || _a === void 0 ? void 0 : _a.trim(); },
            validate: (val) => { var _a; return (((_a = val) === null || _a === void 0 ? void 0 : _a.trim().length) === 0 ? 'Action is required' : true); }
        },
        {
            type: 'text',
            name: 'title',
            message: 'Title',
            format: (val) => { var _a; return (_a = val) === null || _a === void 0 ? void 0 : _a.trim(); },
            validate: (val) => { var _a; return (((_a = val) === null || _a === void 0 ? void 0 : _a.trim().length) === 0 ? 'Title is required' : true); }
        },
        {
            type: 'text',
            name: 'subtitle',
            message: 'Subtitle (optional)',
            format: (val) => { var _a; return (_a = val) === null || _a === void 0 ? void 0 : _a.trim(); }
        }
    ];
    const onCancel = (_prompts, answers) => {
        answers.canceled = true;
        return false;
    };
    const onSubmit = (prompt, answer) => {
        // Abort?
        return prompt.name === 'force' && configExists && !answer;
    };
    Object.assign(params, await prompts_1.default(questions, { onCancel, onSubmit }));
}
function manifestFullPath() {
    return path_1.join(process.cwd(), 'webapp', 'manifest.json');
}
//# sourceMappingURL=add-flp-config.js.map