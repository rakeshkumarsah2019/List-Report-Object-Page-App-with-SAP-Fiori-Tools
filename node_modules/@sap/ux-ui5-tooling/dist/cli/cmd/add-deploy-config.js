"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const yaml_1 = __importDefault(require("yaml"));
const path_1 = require("path");
const fs = __importStar(require("fs"));
const prompts_1 = __importDefault(require("prompts"));
const utils_1 = require("../utils");
const yeoman_environment_1 = __importDefault(require("yeoman-environment"));
const constants_1 = require("./constants");
const add_1 = require("./add");
const dotenv_1 = require("dotenv");
/**
 * Default settings for parameters
 */
const defaultParams = {
    base: 'ui5.yaml',
    config: 'ui5-deploy.yaml'
};
/**
 * Supported CLI parameters
 */
const paramMap = {
    '-c': 'config',
    '-b': 'base',
    '-p': 'package',
    '-t': 'transport',
    '-i': 'index',
    '-f': 'force'
};
/*
 * Add deployment configuration to project.
 * @param args CLI args
 * @returns Successfully added or not
 */
async function addDeployConfig(args) {
    var _a, _b, _c;
    dotenv_1.config();
    const result = {
        added: true
    };
    const supportedTargets = getSupportedTargets();
    let target = (_a = supportedTargets.find((t) => t.name === args[0])) === null || _a === void 0 ? void 0 : _a.name;
    if (target)
        args = args.slice(1);
    const params = utils_1.parseArgs(args, paramMap, defaultParams);
    if (!target) {
        target = (_b = supportedTargets.find((t) => t.default)) === null || _b === void 0 ? void 0 : _b.name;
        if (!target) {
            const { cancel, target: t } = await promptForTarget(params, supportedTargets);
            if (cancel) {
                console.log('Canceled. Exiting');
                return (result.added = false), result;
            }
            else
                target = t;
        }
    }
    const handler = (_c = supportedTargets.find((t) => t.name === target)) === null || _c === void 0 ? void 0 : _c.handler;
    if (!handler) {
        console.log(`Cannot handle target: [${target}]`);
        return (result.added = false), result;
    }
    else
        return handler(params);
}
exports.addDeployConfig = addDeployConfig;
// @todo(ullas): move this to deploy-gen
function getSupportedTargets() {
    const abap = { name: constants_1.Target.ABAP, description: 'ABAP', handler: handleABAP };
    const cf = { name: constants_1.Target.CLOUD_FOUNDRY, description: 'Cloud Foundry', handler: handleCF };
    const ENABLE_CF_SUPPORT = process.env.ENABLE_CF_SUPPORT;
    if (!ENABLE_CF_SUPPORT) {
        abap.default = true;
        return [abap, cf];
    }
    else {
        const possiblyCloudFoundry = fs.existsSync(path_1.join('..', 'cf', 'mta.yaml')) ||
            fs.existsSync(path_1.join('..', 'mta.yaml')) ||
            fs.existsSync(path_1.join('.', 'cf', 'mta.yaml')) ||
            fs.existsSync(path_1.join('.', 'mta.yaml'));
        return possiblyCloudFoundry ? [cf, abap] : [abap, cf];
    }
}
async function handleABAP(params) {
    const result = {
        added: true
    };
    const configAlreadyExists = params.config && fs_1.existsSync(configFileFullPath(params.config));
    const cancel = await promptUser(params, configAlreadyExists);
    if (cancel) {
        console.log('Canceled. Exiting');
        return (result.added = false), result;
    }
    else if (configAlreadyExists && !params.force) {
        console.log(`Choosing not to overwrite existing file ${params.config}`);
        console.log('Please choose to overwrite at the prompt next time or use option -f to force overwrite');
        return (result.added = false), result;
    }
    // create new yaml based on existing yaml
    const doc = yaml_1.default.parseDocument(await fs_1.readFileSync(path_1.join(process.cwd(), params.base), 'utf8'));
    const json = doc.toJSON();
    const cfg = json.server.customMiddleware.find((element) => element['name'] === 'fiori-tools-proxy').configuration;
    const proxy = cfg.backend[0];
    const target = {
        url: proxy.url
    };
    if (proxy.destination) {
        target.destination = proxy.destination;
    }
    if (proxy.scp) {
        target.scp = true;
    }
    const task = {
        name: 'deploy-to-abap',
        afterTask: 'generateVersionInfo',
        configuration: {
            target,
            app: {
                name: json.metadata.name,
                package: params.package,
                transport: params.transport
            }
        }
    };
    if (params.index) {
        task.configuration['index'] = true;
    }
    doc.set('builder', { customTasks: [task] });
    doc.delete('server');
    fs_1.writeFileSync(configFileFullPath(params.config), doc.toString());
    console.info(`${params.config} created.`);
    // add warnings for typical mistakes
    const name = task.configuration.app.name.toUpperCase();
    const packageName = task.configuration.app.package.toUpperCase();
    if (packageName.startsWith('Z') && !name.startsWith('Z')) {
        console.warn('Your package is in the customer space. Please check the correctness of the application name as it might need to start with a Z.');
    }
    updatePackageJson(params, `ui5 build preload --config ${params.config}`);
    return result;
}
exports.handleABAP = handleABAP;
async function handleCF(params) {
    const result = {
        added: true
    };
    try {
        // remember current folder before yo runs and changes it
        const cwd = process.cwd();
        await generateCFArtifacts();
        const deployScript = `rimraf dist && ui5 build preload --include-task=generateManifestBundle generateCachebusterInfo`;
        updatePackageJson(params, deployScript, cwd);
        if (await addFlpConfig())
            result.postTask = () => {
                process.chdir(cwd);
                return add_1.add([add_1.Artifact.FlpConfig, constants_1.Target.CLOUD_FOUNDRY]);
            };
    }
    catch (e) {
        result.added = false;
    }
    return result;
}
function generateCFArtifacts() {
    const env = yeoman_environment_1.default.createEnv();
    env.register(require.resolve('@sap/generator-fiori-deployment/generators/app/index.js'), 'deployment-generator');
    return new Promise((resolve, reject) => {
        env.run('deployment-generator', (err) => {
            if (err)
                reject(err);
            else
                resolve();
        });
    });
}
/*
 * Update package.json with a deploy script
 * @param params command input params
 */
function updatePackageJson(params, deployScript, directory) {
    const filePath = path_1.join((directory !== null && directory !== void 0 ? directory : process.cwd()), 'package.json');
    const packageJson = JSON.parse(fs_1.readFileSync(filePath, 'utf8'));
    packageJson.scripts.deploy = deployScript;
    fs_1.writeFileSync(filePath, JSON.stringify(packageJson, null, 4));
    console.log(`package.json updated.`);
}
async function addFlpConfig() {
    let abort = false;
    const { add } = await prompts_1.default({ type: 'confirm', name: 'add', initial: true, message: 'Add FLP config' }, {
        onCancel: () => {
            abort = true;
            return false;
        }
    });
    return !abort && add;
}
/**
 * Prompt user if parameters are missing
 * @param params already provided params
 */
async function promptUser(params, configAlreadyExists) {
    let cancel = false;
    prompts_1.default.override(params);
    const questions = [
        {
            type: () => (configAlreadyExists ? 'confirm' : false),
            initial: false,
            name: 'force',
            message: `${params.config} exists. Overwrite?`
        },
        {
            type: 'text',
            name: 'package',
            message: 'ABAP package',
            format: (value) => { var _a; return (_a = value) === null || _a === void 0 ? void 0 : _a.trim(); },
            validate: (value) => { var _a; return (((_a = value) === null || _a === void 0 ? void 0 : _a.trim().length) === 0 ? 'Package name required' : true); }
        },
        {
            type: 'text',
            name: 'transport',
            format: (value) => { var _a; return (_a = value) === null || _a === void 0 ? void 0 : _a.trim(); },
            message: 'Transport Request'
        },
        {
            type: 'confirm',
            name: 'index',
            message: 'Generate standalone index.html during deployment'
        }
    ];
    const onSubmit = (prompt, answer) => {
        // Abort?
        return prompt.name === 'force' && configAlreadyExists && !answer;
    };
    const onCancel = () => {
        cancel = true;
        return false;
    };
    Object.assign(params, await prompts_1.default(questions, { onCancel, onSubmit }));
    return cancel;
}
async function promptForTarget(params, supportedTargets) {
    const result = { cancel: false };
    prompts_1.default.override(params);
    const questions = [
        {
            type: 'select',
            name: 'target',
            choices: supportedTargets.map((t) => {
                return { title: t.description, value: t.name };
            }),
            message: 'Choose target'
        }
    ];
    const onCancel = () => {
        result.cancel = true;
        return false;
    };
    if (questions.length > 0) {
        Object.assign(result, await prompts_1.default(questions, { onCancel }));
    }
    return result;
}
/**
 * Return the full path of the config file
 *
 * @param configFile
 */
function configFileFullPath(configFile) {
    return path_1.join(process.cwd(), configFile);
}
//# sourceMappingURL=add-deploy-config.js.map