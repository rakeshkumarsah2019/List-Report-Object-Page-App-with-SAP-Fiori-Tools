"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yazl_1 = require("yazl");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const config_1 = require("../../utils/config");
const static_1 = require("./static");
const i18next_1 = __importDefault(require("i18next"));
/**
 * Helper function for throwing a missing property error
 * @param property Invalid missing property
 */
function throwConfigMissingError(property) {
    throw new Error(i18next_1.default.t('ERROR_INVALID_DEPLOYMENT_CONFIGURATION', { property: property }));
}
/**
 * Validates a deployment config. Throws an error is the configuration is invalid
 * @param config config that is to be validated
 */
function validateConfig(config) {
    config_1.replaceEnvVariables(config);
    if (config.target) {
        if (!config.target.url)
            throwConfigMissingError('target-url');
        if (config.target.client) {
            config.target.client = config.target.client + '';
            if (config.target.client.length === 1) {
                config.target.client = `00${config.target.client}`;
            }
            else if (config.target.client.length === 2) {
                config.target.client = `0${config.target.client}`;
            }
        }
    }
    else {
        throwConfigMissingError('target');
    }
    if (config.app) {
        if (!config.app.name)
            throwConfigMissingError('app-name');
    }
    else {
        throwConfigMissingError('app');
    }
    if (config.credentials) {
        if (!config.credentials.serviceKeys && config.credentials.username) {
            if (!config.credentials.password)
                throwConfigMissingError('password');
        }
    }
    return true;
}
exports.validateConfig = validateConfig;
/**
 * Create a zip file based on the given object
 * @param zip ZipFile as object
 */
function writeZipFile(zip) {
    return new Promise((resolve) => {
        const archive = path_1.default.resolve(process.cwd(), 'archive.zip');
        zip.outputStream.pipe(fs_1.createWriteStream(archive));
        zip.end({ forceZip64Format: false }, () => {
            resolve(archive);
        });
    });
}
/**
 * Create a zip file with all files in the virtual project workspace.
 * @param workspace UI5 project workspace
 * @param namespace UI5 project name
 * @param config Deployment configuration
 * @param log Logger
 */
async function createArchive(workspace, namespace, config, log) {
    log.info(i18next_1.default.t('INFO_CREATE_ARCHIVE'));
    const zip = new yazl_1.ZipFile();
    const prefix = `/resources/${namespace}/`;
    const files = await workspace.byGlob(`${prefix}**`);
    await Promise.all(files.map(async (file) => {
        if (!(config.exclude || []).some((regex) => file.getPath().match(regex))) {
            const filePath = file.getPath().replace(prefix, '');
            const buffer = await file.getBuffer();
            zip.addBuffer(buffer, filePath);
            log.info(i18next_1.default.t('INFO_FILE_PATH_ADDED', { path: filePath }));
            if (config.index && filePath === 'manifest.json') {
                const manifest = JSON.parse(buffer.toString());
                zip.addBuffer(static_1.generateIndexHtml(manifest['sap.app'].id), 'index.html');
                log.info(i18next_1.default.t('INDEX_HTML_ADDED'));
            }
        }
    }));
    delete config.exclude;
    return writeZipFile(zip);
}
exports.createArchive = createArchive;
//# sourceMappingURL=steps.js.map