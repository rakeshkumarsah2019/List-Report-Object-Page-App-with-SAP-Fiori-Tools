/* eslint-disable @typescript-eslint/camelcase */
import open = require('open');
import http from 'http';
import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';
import express from 'express';
import { SystemConfig, Credentials, ServiceInfo, ServiceName } from '../config';
import { readFileSync } from 'fs';
import { Logger } from '../utils';
import { Connection } from './connection';
import { Cookies, CSRF } from '.';
import qs from 'qs';
import { getSecureStore } from '../secure-store';
import { join } from 'path';
import { AddressInfo } from 'net';

class Redirect {
    public static readonly path = '/oauth/client/redirect';
    private readonly port;

    constructor(port: number) {
        this.port = port;
    }

    public url(): string {
        return `http://localhost:${this.port}${Redirect.path}`;
    }
}

const timeoutMs = 3 * 60 * 1000; // 3 minutes

const timeString = (ms: number): string => {
    const min = ms / 60 / 1000;
    if (min > 1) return `${min} minutes`;
    else if (min === 1) return '1 minute';
    else return `${ms / 1000} seconds`;
};

function getAuthCode({
    uaa,
    log,
    timeout = timeoutMs
}: {
    uaa: Uaa;
    log: Logger;
    timeout?: number;
}): Promise<{ authCode: string; redirect: Redirect }> {
    return new Promise((resolve, reject) => {
        const app = express();
        const server = http.createServer(app);
        // eslint-disable-next-line prefer-const
        let redirect: Redirect;
        const handleTimeout = (): void => {
            server.close();
            reject(`Timeout. Did not get a response within ${timeString(timeout)}`);
        };
        const timer = setTimeout(handleTimeout, timeout);
        app.get(Redirect.path, (req, res) => {
            res.sendFile(join(__dirname, '..', '..', 'static', 'success.html'));
            log.info('Got authCode');
            resolve({ authCode: req.query.code + '', redirect });
            if (timer) clearTimeout(timer);
            server.close();
        });

        // Start listening. Let the OS assign an available port
        server.listen();
        redirect = new Redirect((server.address() as AddressInfo).port);
        const oauthUrl = uaa.getAuthCodeUrl({ redirectUri: redirect.url() });
        open(oauthUrl);
    });
}

async function getAccessToken({ uaa, url, log }: { uaa: Uaa; url: string; log: Logger }): Promise<string> {
    const keyStore = getSecureStore(log);
    const refreshTokenServiceName = ServiceName.RefreshToken;

    const host = new URL(url).host;
    const refreshToken = await keyStore.retrieve<string>(refreshTokenServiceName, host);
    let response: AxiosResponse;
    let startFreshLogin = false;
    if (refreshToken) {
        log.info('Got stored refresh token');
        const tokenRequest = uaa.getTokenRequestForRefreshToken(refreshToken);
        try {
            response = await axios.request(tokenRequest);

            // Has refresh token expired?
            if (response.status === 401 || response.data.error === 'invalid_token') {
                startFreshLogin = true;
                log.warn('Cannot use stored refresh token. Starting fresh request');
            } else {
                if (refreshToken !== response.data.refresh_token) {
                    log.info('Storing refresh token');
                    await keyStore.save(refreshTokenServiceName, host, response.data.refresh_token);
                }
            }
        } catch (e) {
            startFreshLogin = true;
        }
    } else {
        log.warn('Could not get stored refresh token');
    }

    if (!refreshToken || startFreshLogin) {
        const { authCode, redirect } = await getAuthCode({ uaa, log });
        const tokenRequest = uaa.getTokenRequestForAuthCode({
            redirectUri: redirect.url(), // Redirection URL needs to match
            authCode
        });
        response = await axios.request(tokenRequest);
        log.info('Storing refresh token');
        await keyStore.save(refreshTokenServiceName, host, response.data.refresh_token);
    }
    log.info('Got access token successfully');
    return response.data.access_token;
}

class Uaa {
    private readonly serviceInfo: ServiceInfo['uaa'];

    constructor(serviceInfo) {
        this.validatePropertyExists(serviceInfo.clientid, 'Client ID missing');
        this.validatePropertyExists(serviceInfo.clientsecret, 'Client Secret missing');
        this.validatePropertyExists(serviceInfo.url, 'UAA URL missing');
        this.serviceInfo = serviceInfo;
    }

    private validatePropertyExists(property: string, errMsg: string): void {
        if (!property) throw Error(errMsg);
    }

    public getAuthCodeUrl({ redirectUri }): string {
        return (
            this.serviceInfo.url +
            '/oauth/authorize?' +
            qs.stringify({
                response_type: 'code',
                redirect_uri: redirectUri,
                client_id: this.serviceInfo.clientid
            })
        );
    }

    public getTokenRequestForAuthCode({ redirectUri, authCode }): AxiosRequestConfig {
        return {
            url: this.serviceInfo.url + '/oauth/token',
            auth: { username: this.serviceInfo.clientid, password: this.serviceInfo.clientsecret },
            method: 'POST',
            data: qs.stringify({
                code: authCode,
                grant_type: 'authorization_code',
                redirect_uri: redirectUri,
                response_type: 'token'
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json'
            }
        };
    }

    public getTokenRequestForRefreshToken(refreshToken): AxiosRequestConfig {
        return {
            url: this.serviceInfo.url + '/oauth/token',
            auth: { username: this.serviceInfo.clientid, password: this.serviceInfo.clientsecret },
            method: 'POST',
            data: qs.stringify({
                grant_type: 'refresh_token',
                refresh_token: refreshToken
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json'
            }
        };
    }
}

async function newConnection(target: SystemConfig, accessToken: string): Promise<Connection> {
    const url = `${target.url}${target.service}${target.client ? '?sap-client=' + target.client : ''}`;
    const response = await axios.get(url, {
        headers: {
            authorization: `bearer ${accessToken}`,
            [CSRF.requestHeaderName]: CSRF.requestHeaderValue
        }
    });
    return {
        cookies: new Cookies().setCookie(response),
        xsrfToken: response.headers[CSRF.responseHeaderName]
    };
}

export function getServiceInfo(credentials: Credentials): ServiceInfo {
    try {
        if (credentials.serviceKeysContents) {
            return typeof credentials.serviceKeyContents === 'string'
                ? JSON.parse(credentials.serviceKeysContents as string)
                : credentials.serviceKeysContents;
        }
        return JSON.parse(readFileSync(credentials.serviceKeys, 'utf-8'));
    } catch (e) {
        console.log(e);
        throw new Error('Error parsing service keys');
    }
}

interface UaaUtils {
    serviceInfo: (credentials: Credentials) => ServiceInfo;
    accessToken: ({ uaa, url, log }: { uaa: Uaa; url: string; log: Logger }) => Promise<string>;
    connection: (target: SystemConfig, accessToken: string) => Promise<Connection>;
}

export const defaultUtils: UaaUtils = {
    serviceInfo: getServiceInfo,
    connection: newConnection,
    accessToken: getAccessToken
};

export async function connectUsingUaa(
    target: SystemConfig,
    credentials: Credentials,
    log: Logger = console,
    { serviceInfo, connection, accessToken }: UaaUtils = defaultUtils
): Promise<Connection> {
    try {
        const uaa = new Uaa((credentials.serviceInfo as ServiceInfo)?.uaa || serviceInfo(credentials).uaa);
        const token = await accessToken({ uaa, url: target.url, log });
        return await connection(target, token);
    } catch (e) {
        log.error(e.message);
        throw e;
    }
}
