import { ODataClient, ODataClientOptions } from './oDataClient';
import { getServiceInfo } from '../connection/uaaOauth';

/**
 * OData versions supported by the catalog service
 */
export enum ODataVersion {
    v2 = '2',
    v4 = '4'
}

/**
 * Structure representing annotations (including their definitions)
 */
export interface Annotations {
    TechnicalName: string;
    Version: string;
    Definitions: string;
    Uri: string;
}

/**
 * Structure representing a service
 */
export interface Service {
    ID: string;
    Description: string;
    Title: string;
    MetadataUrl: string;
    ServiceUrl: string;
    TechnicalName: string;
    Version: string;
}

export interface CatalogOptions extends ODataClientOptions {
    odataVersion?: ODataVersion;
}

/**
 * Filter options to search for annotations
 */
export interface FilterOptions {
    id?: string;
    title?: string;
    path?: string;
}
/**
 * Extension of the generic OData client simplifying the consumption of the SAP OData Catalog service
 */
export class Catalog extends ODataClient {
    public constructor({
        odataVersion = ODataVersion.v2,
        system,
        credentials = undefined,
        log = console,
        connection = undefined
    }: CatalogOptions) {
        if (credentials?.serviceKeys || credentials?.serviceKeysContents) {
            const serviceInfo = getServiceInfo(credentials);
            credentials.serviceInfo = serviceInfo;
            system.url = serviceInfo.url;
            if (serviceInfo.catalogs?.abap?.path) system.service = serviceInfo.catalogs.abap.path;
        } else {
            system.service = system.service ?? `/sap/opu/odata/IWFND/CATALOGSERVICE;v=${odataVersion}`;
        }

        super({ system, credentials, log, connection });
    }

    /**
     * List all available Services
     */
    public async listServices(): Promise<Service[]> {
        return this.get<Service[]>('/ServiceCollection');
    }

    /**
     * Find a specific service by title
     * @param title service title
     */
    protected async findService({ title, path }: FilterOptions): Promise<Service> {
        if (!title) {
            title = path
                .replace(/\/$/, '')
                .split('/')
                .pop();
            if (!title) throw new Error(`Cannot determine service title from path: ${path}`);
        }

        title = title.toUpperCase(); // Same as WebIDE. #6368 for details.

        // TODO: use ServiceUrl instead of title extractio
        // filter += '$filter=' + encodeURIComponent(`ServiceUrl eq "${encodeURIComponent(this.system.url + path)}"`);
        const services = await this.get<Service[]>(
            `/ServiceCollection/?$filter=Title%20eq%20%27${title}%27&$format=json`
        );
        if (services.length > 1) {
            this.log.warn('Service filter was not sufficient to identify one service.');
        }
        return services.length > 0 ? services[0] : undefined;
    }

    /**
     * Get all annotations available for the service matching one of the below filter options
     * @param id service id
     * @param title sevice title
     * @param path service path
     */
    public async getAnnotations({ id, title, path }: FilterOptions): Promise<Annotations[]> {
        if (!id && !title && !path) throw new Error('No filter parameters passed in');

        const serviceAnnotations = await this.getServiceAnnotations({ id, title, path });
        const annotations: Annotations[] = [];
        if (serviceAnnotations) {
            const httpClient = await this.getClient();
            for (const service of serviceAnnotations) {
                const path = `/Annotations(TechnicalName='${encodeURIComponent(service.TechnicalName)}',Version='${
                    service.Version
                }')/$value/`;
                const response = await httpClient.get(path);
                if (response?.data) {
                    annotations.push({
                        TechnicalName: service.TechnicalName,
                        Version: service.Version,
                        Definitions: response.data,
                        Uri: this.system.service + path
                    });
                } else {
                    this.log.warn(
                        `No annotations found for TechnicalName=${service.TechnicalName}, Version=${service.Version}`
                    );
                }
            }
        }
        return annotations;
    }

    private async getServiceAnnotations({ id, title, path }: FilterOptions): Promise<Service[]> {
        if (!id) {
            const serivceInfo = await this.findService({ title, path });
            if (serivceInfo) {
                id = serivceInfo.ID;
            }
        }

        if (id) {
            return this.get<Service[]>(`/ServiceCollection('${encodeURIComponent(id)}')/Annotations?$format=json`);
        } else {
            return undefined;
        }

        /*
        else if (title) {
            const serivceInfo = await this.findService(title);
            return this.get<Service[]>(`/ServiceCollection('${serivceInfo.ID}')/Annotations?$format=json`);
        } else if (path) {
            const serviceTitle = path
                .replace(/\/$/, '')
                .split('/')
                .pop();
            if (!serviceTitle) throw new Error(`Cannot determine service title from path: ${path}`);
            const serivceInfo = await this.findService(serviceTitle);
            return this.get<Service[]>(`/ServiceCollection('${serivceInfo.ID}')/Annotations?$format=json`);
        }
        */
    }
}
