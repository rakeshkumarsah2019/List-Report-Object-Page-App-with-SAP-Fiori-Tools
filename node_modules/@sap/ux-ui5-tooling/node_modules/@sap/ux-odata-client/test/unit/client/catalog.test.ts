import { Catalog, ODataVersion, CatalogOptions } from '../../../src/client/catalog';
import { AxiosInstance } from 'axios';

const mockGet = jest.fn();
const mockAxiosInstance = ({ get: mockGet } as unknown) as AxiosInstance;

class MockCatalog extends Catalog {
    constructor({
        odataVersion = ODataVersion.v2,
        system,
        credentials = undefined,
        log = console,
        connection = undefined
    }: CatalogOptions) {
        super({ odataVersion, system, credentials, log, connection });
    }

    protected async getClient(): Promise<AxiosInstance> {
        return Promise.resolve(mockAxiosInstance);
    }
}

describe('Catalog:', () => {
    beforeEach(() => {
        mockGet.mockClear();
    });

    it('listServices() returns a list of services', async () => {
        const services = [
            {
                ID: 'id1',
                Description: 'desc1',
                Title: 'title1',
                MetadataUrl: 'url1',
                TechnicalName: 'tech1',
                Version: 'ver1'
            }
        ];
        mockGet.mockResolvedValueOnce({ data: { d: services } });
        const catalog = new MockCatalog({ system: { url: 'http://url' } });
        const actualResponse = await catalog.listServices();
        expect(actualResponse).toBe(services);
    });

    it('getAnnotations() throws an error if no parameters are passed in', async () => {
        const catalog = new MockCatalog({ system: { url: 'http://url' } });
        await expect(catalog.getAnnotations({})).rejects.toThrow(/no filter parameters passed/i);
    });

    it('getAnnotations() returns multiple annotations, if found', async () => {
        // Service technical names
        const expectedAnnotationServices = [
            { TechnicalName: 'one', Version: '1' },
            { TechnicalName: 'two', Version: '1' }
        ];
        const expectedAnnotations = ['def1', 'def2'];

        mockGet.mockResolvedValueOnce({ data: { d: { results: expectedAnnotationServices } } });
        expectedAnnotations.forEach((a) => {
            mockGet.mockResolvedValueOnce({ data: a });
        });

        const catalog = new MockCatalog({ system: { url: 'http://url' } });
        const actualAnnotations = await catalog.getAnnotations({ id: 'someService' });

        expectedAnnotations.forEach((val, idx) => {
            expect(actualAnnotations[idx].TechnicalName).toBe(expectedAnnotationServices[idx].TechnicalName);
            expect(actualAnnotations[idx].Version).toBe(expectedAnnotationServices[idx].Version);
            expect(actualAnnotations[idx].Definitions).toBe(expectedAnnotations[idx]);
        });
    });

    it('getAnnotations() - 2 technical names, only 1 set of annotations', async () => {
        // Service technical names
        const expectedAnnotationServices = [
            { TechnicalName: 'one', Version: '1' },
            { TechnicalName: 'two', Version: '1' }
        ];
        const expectedAnnotations = ['def1'];

        mockGet.mockResolvedValueOnce({ data: { d: { results: expectedAnnotationServices } } });
        expectedAnnotations.forEach((a) => {
            mockGet.mockResolvedValueOnce({ data: a });
        });

        const catalog = new MockCatalog({ system: { url: 'http://url' } });
        const actualAnnotations = await catalog.getAnnotations({ id: 'someService' });

        expectedAnnotations.forEach((val, idx) => {
            expect(actualAnnotations[idx].TechnicalName).toBe(expectedAnnotationServices[idx].TechnicalName);
            expect(actualAnnotations[idx].Version).toBe(expectedAnnotationServices[idx].Version);
            expect(actualAnnotations[idx].Definitions).toBe(expectedAnnotations[idx]);
        });
    });

    it('getAnnotations() - 2 technical names, no annotations', async () => {
        // Service technical names
        const expectedAnnotationServices = [
            { TechnicalName: 'one', Version: '1' },
            { TechnicalName: 'two', Version: '1' }
        ];
        mockGet.mockResolvedValueOnce({ data: { d: { results: expectedAnnotationServices } } });
        mockGet.mockResolvedValueOnce(undefined);

        const catalog = new MockCatalog({ system: { url: 'http://url' } });
        const actualAnnotations = await catalog.getAnnotations({ id: 'someService' });

        expect(actualAnnotations).toEqual([]);
    });

    it('getAnnotations() - no technical names, no annotations', async () => {
        // Service technical names
        const expectedAnnotationServices = [];
        mockGet.mockResolvedValueOnce({ data: { d: { results: expectedAnnotationServices } } });

        const catalog = new MockCatalog({ system: { url: 'http://url' } });
        const actualAnnotations = await catalog.getAnnotations({ id: 'someService' });

        expect(actualAnnotations).toEqual([]);
    });

    it('getAnnotations() - no technical names (returns undefined), no annotations', async () => {
        // Service technical names
        mockGet.mockResolvedValueOnce(undefined);

        const catalog = new MockCatalog({ system: { url: 'http://url' } });
        const actualAnnotations = await catalog.getAnnotations({ id: 'someService' });

        expect(actualAnnotations).toEqual([]);
    });
});
