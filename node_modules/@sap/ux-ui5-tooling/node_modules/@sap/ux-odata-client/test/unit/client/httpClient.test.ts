import axios from 'axios';
import { mocked } from 'ts-jest/utils';
import { newHttpClient } from '../../../src/client/httpClient';
import { CSRF, connect, Cookies } from '../../../src/connection/index';

jest.mock('axios');
const mockAxios = mocked(axios, true);

jest.mock('../../../src/connection/index', () => {
    return {
        ...jest.requireActual('../../../src/connection/index'),
        connect: jest.fn()
    };
});
const mockConnect = mocked(connect, true);

describe('HTTPClient', () => {
    beforeEach(() => {
        mockAxios.mockClear();
        jest.clearAllMocks();
    });

    it('Passes CSRF token to GET', async () => {
        const xsrfToken = 'token1';
        mockConnect.mockImplementationOnce(async () => Promise.resolve({ cookies: new Cookies(), xsrfToken }));
        await newHttpClient({ system: { url: 'http://url' }, credentials: {}, log: console });
        expect(mockAxios.create.mock.calls).toHaveProperty(['0', '0', 'headers', CSRF.responseHeaderName], xsrfToken);
    });

    it('Passes cookies to GET', async () => {
        const cookies = new Cookies().addCookie('cookie1=value1').addCookie('cookie2=value2');
        mockConnect.mockImplementationOnce(async () => Promise.resolve({ cookies }));
        await newHttpClient({ system: { url: 'http://url' }, credentials: {}, log: console });
        expect(mockAxios.create.mock.calls).toHaveProperty(['0', '0', 'headers', 'Cookie'], cookies.toString());
    });

    it('"withCredentials" is true when calling GET', async () => {
        mockConnect.mockImplementationOnce(async () => Promise.resolve({ cookies: new Cookies() }));
        await newHttpClient({ system: { url: 'http://url' }, credentials: {}, log: console });
        expect(mockAxios.create.mock.calls).toHaveProperty(['0', '0', 'withCredentials'], true);
    });

    it('Throws an error on connection failure', () => {
        mockConnect.mockRejectedValueOnce('Connection error');
        const newCall = newHttpClient({ system: { url: 'http://url' }, credentials: {}, log: console });
        expect(newCall).rejects.toThrow();
    });
});
