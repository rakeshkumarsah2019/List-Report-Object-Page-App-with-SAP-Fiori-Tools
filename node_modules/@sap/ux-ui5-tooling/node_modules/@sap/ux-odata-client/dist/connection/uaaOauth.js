"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/camelcase */
const open = require("open");
const http_1 = __importDefault(require("http"));
const axios_1 = __importDefault(require("axios"));
const express_1 = __importDefault(require("express"));
const config_1 = require("../config");
const fs_1 = require("fs");
const _1 = require(".");
const qs_1 = __importDefault(require("qs"));
const secure_store_1 = require("../secure-store");
const path_1 = require("path");
class Redirect {
    constructor(port) {
        this.port = port;
    }
    url() {
        return `http://localhost:${this.port}${Redirect.path}`;
    }
}
Redirect.path = '/oauth/client/redirect';
const timeoutMs = 3 * 60 * 1000; // 3 minutes
const timeString = (ms) => {
    const min = ms / 60 / 1000;
    if (min > 1)
        return `${min} minutes`;
    else if (min === 1)
        return '1 minute';
    else
        return `${ms / 1000} seconds`;
};
function getAuthCode({ uaa, log, timeout = timeoutMs }) {
    return new Promise((resolve, reject) => {
        const app = express_1.default();
        const server = http_1.default.createServer(app);
        // eslint-disable-next-line prefer-const
        let redirect;
        const handleTimeout = () => {
            server.close();
            reject(`Timeout. Did not get a response within ${timeString(timeout)}`);
        };
        const timer = setTimeout(handleTimeout, timeout);
        app.get(Redirect.path, (req, res) => {
            res.sendFile(path_1.join(__dirname, '..', '..', 'static', 'success.html'));
            log.info('Got authCode');
            resolve({ authCode: req.query.code + '', redirect });
            if (timer)
                clearTimeout(timer);
            server.close();
        });
        // Start listening. Let the OS assign an available port
        server.listen();
        redirect = new Redirect(server.address().port);
        const oauthUrl = uaa.getAuthCodeUrl({ redirectUri: redirect.url() });
        open(oauthUrl);
    });
}
async function getAccessToken({ uaa, url, log }) {
    const keyStore = secure_store_1.getSecureStore(log);
    const refreshTokenServiceName = config_1.ServiceName.RefreshToken;
    const host = new URL(url).host;
    const refreshToken = await keyStore.retrieve(refreshTokenServiceName, host);
    let response;
    let startFreshLogin = false;
    if (refreshToken) {
        log.info('Got stored refresh token');
        const tokenRequest = uaa.getTokenRequestForRefreshToken(refreshToken);
        try {
            response = await axios_1.default.request(tokenRequest);
            // Has refresh token expired?
            if (response.status === 401 || response.data.error === 'invalid_token') {
                startFreshLogin = true;
                log.warn('Cannot use stored refresh token. Starting fresh request');
            }
            else {
                if (refreshToken !== response.data.refresh_token) {
                    log.info('Storing refresh token');
                    await keyStore.save(refreshTokenServiceName, host, response.data.refresh_token);
                }
            }
        }
        catch (e) {
            startFreshLogin = true;
        }
    }
    else {
        log.warn('Could not get stored refresh token');
    }
    if (!refreshToken || startFreshLogin) {
        const { authCode, redirect } = await getAuthCode({ uaa, log });
        const tokenRequest = uaa.getTokenRequestForAuthCode({
            redirectUri: redirect.url(),
            authCode
        });
        response = await axios_1.default.request(tokenRequest);
        log.info('Storing refresh token');
        await keyStore.save(refreshTokenServiceName, host, response.data.refresh_token);
    }
    log.info('Got access token successfully');
    return response.data.access_token;
}
class Uaa {
    constructor(serviceInfo) {
        this.validatePropertyExists(serviceInfo.clientid, 'Client ID missing');
        this.validatePropertyExists(serviceInfo.clientsecret, 'Client Secret missing');
        this.validatePropertyExists(serviceInfo.url, 'UAA URL missing');
        this.serviceInfo = serviceInfo;
    }
    validatePropertyExists(property, errMsg) {
        if (!property)
            throw Error(errMsg);
    }
    getAuthCodeUrl({ redirectUri }) {
        return (this.serviceInfo.url +
            '/oauth/authorize?' +
            qs_1.default.stringify({
                response_type: 'code',
                redirect_uri: redirectUri,
                client_id: this.serviceInfo.clientid
            }));
    }
    getTokenRequestForAuthCode({ redirectUri, authCode }) {
        return {
            url: this.serviceInfo.url + '/oauth/token',
            auth: { username: this.serviceInfo.clientid, password: this.serviceInfo.clientsecret },
            method: 'POST',
            data: qs_1.default.stringify({
                code: authCode,
                grant_type: 'authorization_code',
                redirect_uri: redirectUri,
                response_type: 'token'
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json'
            }
        };
    }
    getTokenRequestForRefreshToken(refreshToken) {
        return {
            url: this.serviceInfo.url + '/oauth/token',
            auth: { username: this.serviceInfo.clientid, password: this.serviceInfo.clientsecret },
            method: 'POST',
            data: qs_1.default.stringify({
                grant_type: 'refresh_token',
                refresh_token: refreshToken
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json'
            }
        };
    }
}
async function newConnection(target, accessToken) {
    const url = `${target.url}${target.service}${target.client ? '?sap-client=' + target.client : ''}`;
    const response = await axios_1.default.get(url, {
        headers: {
            authorization: `bearer ${accessToken}`,
            [_1.CSRF.requestHeaderName]: _1.CSRF.requestHeaderValue
        }
    });
    return {
        cookies: new _1.Cookies().setCookie(response),
        xsrfToken: response.headers[_1.CSRF.responseHeaderName]
    };
}
function getServiceInfo(credentials) {
    try {
        if (credentials.serviceKeysContents) {
            return typeof credentials.serviceKeyContents === 'string'
                ? JSON.parse(credentials.serviceKeysContents)
                : credentials.serviceKeysContents;
        }
        return JSON.parse(fs_1.readFileSync(credentials.serviceKeys, 'utf-8'));
    }
    catch (e) {
        console.log(e);
        throw new Error('Error parsing service keys');
    }
}
exports.getServiceInfo = getServiceInfo;
exports.defaultUtils = {
    serviceInfo: getServiceInfo,
    connection: newConnection,
    accessToken: getAccessToken
};
async function connectUsingUaa(target, credentials, log = console, { serviceInfo, connection, accessToken } = exports.defaultUtils) {
    var _a;
    try {
        const uaa = new Uaa(((_a = credentials.serviceInfo) === null || _a === void 0 ? void 0 : _a.uaa) || serviceInfo(credentials).uaa);
        const token = await accessToken({ uaa, url: target.url, log });
        return await connection(target, token);
    }
    catch (e) {
        log.error(e.message);
        throw e;
    }
}
exports.connectUsingUaa = connectUsingUaa;
//# sourceMappingURL=uaaOauth.js.map