"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const oDataClient_1 = require("./oDataClient");
const uaaOauth_1 = require("../connection/uaaOauth");
/**
 * OData versions supported by the catalog service
 */
var ODataVersion;
(function (ODataVersion) {
    ODataVersion["v2"] = "2";
    ODataVersion["v4"] = "4";
})(ODataVersion = exports.ODataVersion || (exports.ODataVersion = {}));
/**
 * Extension of the generic OData client simplifying the consumption of the SAP OData Catalog service
 */
class Catalog extends oDataClient_1.ODataClient {
    constructor({ odataVersion = ODataVersion.v2, system, credentials = undefined, log = console, connection = undefined }) {
        var _a, _b, _c, _d, _e;
        if (((_a = credentials) === null || _a === void 0 ? void 0 : _a.serviceKeys) || ((_b = credentials) === null || _b === void 0 ? void 0 : _b.serviceKeysContents)) {
            const serviceInfo = uaaOauth_1.getServiceInfo(credentials);
            credentials.serviceInfo = serviceInfo;
            system.url = serviceInfo.url;
            if ((_d = (_c = serviceInfo.catalogs) === null || _c === void 0 ? void 0 : _c.abap) === null || _d === void 0 ? void 0 : _d.path)
                system.service = serviceInfo.catalogs.abap.path;
        }
        else {
            system.service = (_e = system.service, (_e !== null && _e !== void 0 ? _e : `/sap/opu/odata/IWFND/CATALOGSERVICE;v=${odataVersion}`));
        }
        super({ system, credentials, log, connection });
    }
    /**
     * List all available Services
     */
    async listServices() {
        return this.get('/ServiceCollection');
    }
    /**
     * Find a specific service by title
     * @param title service title
     */
    async findService({ title, path }) {
        if (!title) {
            title = path
                .replace(/\/$/, '')
                .split('/')
                .pop();
            if (!title)
                throw new Error(`Cannot determine service title from path: ${path}`);
        }
        title = title.toUpperCase(); // Same as WebIDE. #6368 for details.
        // TODO: use ServiceUrl instead of title extractio
        // filter += '$filter=' + encodeURIComponent(`ServiceUrl eq "${encodeURIComponent(this.system.url + path)}"`);
        const services = await this.get(`/ServiceCollection/?$filter=Title%20eq%20%27${title}%27&$format=json`);
        if (services.length > 1) {
            this.log.warn('Service filter was not sufficient to identify one service.');
        }
        return services.length > 0 ? services[0] : undefined;
    }
    /**
     * Get all annotations available for the service matching one of the below filter options
     * @param id service id
     * @param title sevice title
     * @param path service path
     */
    async getAnnotations({ id, title, path }) {
        var _a;
        if (!id && !title && !path)
            throw new Error('No filter parameters passed in');
        const serviceAnnotations = await this.getServiceAnnotations({ id, title, path });
        const annotations = [];
        if (serviceAnnotations) {
            const httpClient = await this.getClient();
            for (const service of serviceAnnotations) {
                const path = `/Annotations(TechnicalName='${encodeURIComponent(service.TechnicalName)}',Version='${service.Version}')/$value/`;
                const response = await httpClient.get(path);
                if ((_a = response) === null || _a === void 0 ? void 0 : _a.data) {
                    annotations.push({
                        TechnicalName: service.TechnicalName,
                        Version: service.Version,
                        Definitions: response.data,
                        Uri: this.system.service + path
                    });
                }
                else {
                    this.log.warn(`No annotations found for TechnicalName=${service.TechnicalName}, Version=${service.Version}`);
                }
            }
        }
        return annotations;
    }
    async getServiceAnnotations({ id, title, path }) {
        if (!id) {
            const serivceInfo = await this.findService({ title, path });
            if (serivceInfo) {
                id = serivceInfo.ID;
            }
        }
        if (id) {
            return this.get(`/ServiceCollection('${encodeURIComponent(id)}')/Annotations?$format=json`);
        }
        else {
            return undefined;
        }
        /*
        else if (title) {
            const serivceInfo = await this.findService(title);
            return this.get<Service[]>(`/ServiceCollection('${serivceInfo.ID}')/Annotations?$format=json`);
        } else if (path) {
            const serviceTitle = path
                .replace(/\/$/, '')
                .split('/')
                .pop();
            if (!serviceTitle) throw new Error(`Cannot determine service title from path: ${path}`);
            const serivceInfo = await this.findService(serviceTitle);
            return this.get<Service[]>(`/ServiceCollection('${serivceInfo.ID}')/Annotations?$format=json`);
        }
        */
    }
}
exports.Catalog = Catalog;
//# sourceMappingURL=catalog.js.map