"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformTermToGenericType = exports.convertTypes = void 0;
var Path = /** @class */ (function () {
    function Path(pathExpression, targetName) {
        this.path = pathExpression.Path;
        this.type = "Path";
        this.$target = targetName;
    }
    return Path;
}());
function unalias(references, aliasedValue) {
    if (!references.referenceMap) {
        references.referenceMap = references.reduce(function (map, reference) {
            map[reference.alias] = reference;
            return map;
        }, {});
    }
    if (!aliasedValue) {
        return aliasedValue;
    }
    var _a = aliasedValue.split("."), alias = _a[0], value = _a[1];
    var reference = references.referenceMap[alias];
    if (reference) {
        return reference.namespace + "." + value;
    }
    else {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        if (aliasedValue.indexOf("@") !== -1) {
            var _b = aliasedValue.split("@"), preAlias = _b[0], postAlias = _b[1];
            return preAlias + "@" + unalias(references, postAlias);
        }
        else {
            return aliasedValue;
        }
    }
}
function buildObjectMap(parserOutput) {
    var objectMap = {};
    if (parserOutput.schema.entityContainer && parserOutput.schema.entityContainer.fullyQualifiedName) {
        objectMap[parserOutput.schema.entityContainer.fullyQualifiedName] = parserOutput.schema.entityContainer;
    }
    parserOutput.schema.entitySets.forEach(function (entitySet) {
        objectMap[entitySet.fullyQualifiedName] = entitySet;
    });
    parserOutput.schema.actions.forEach(function (action) {
        objectMap[action.fullyQualifiedName] = action;
        action.parameters.forEach(function (parameter) {
            objectMap[parameter.fullyQualifiedName] = parameter;
        });
    });
    parserOutput.schema.entityTypes.forEach(function (entityType) {
        objectMap[entityType.fullyQualifiedName] = entityType;
        entityType.entityProperties.forEach(function (property) {
            objectMap[property.fullyQualifiedName] = property;
        });
        entityType.navigationProperties.forEach(function (navProperty) {
            objectMap[navProperty.fullyQualifiedName] = navProperty;
        });
    });
    Object.keys(parserOutput.schema.annotations).forEach(function (annotationSource) {
        parserOutput.schema.annotations[annotationSource].forEach(function (annotationList) {
            var currentTargetName = unalias(parserOutput.references, annotationList.target);
            annotationList.annotations.forEach(function (annotation) {
                var annotationFQN = "/" + currentTargetName + "@" + unalias(parserOutput.references, annotation.term);
                if (annotation.qualifier) {
                    annotationFQN += "#" + annotation.qualifier;
                }
                objectMap[annotationFQN] = annotation;
                annotation.fullyQualifiedName = annotationFQN;
            });
        });
    });
    return objectMap;
}
function combinePath(currentTarget, path) {
    if (path.startsWith("@")) {
        return currentTarget + path;
    }
    else {
        return currentTarget + "/" + path;
    }
}
function resolveTarget(objectMap, currentTarget, path, pathOnly) {
    if (pathOnly === void 0) { pathOnly = false; }
    if (!path) {
        return undefined;
    }
    path = combinePath(currentTarget.fullyQualifiedName, path);
    var pathSplit = path.split("/");
    var currentPath = path;
    var target = pathSplit.reduce(function (currentValue, pathPart) {
        if (!currentValue) {
            currentPath = pathPart;
        }
        else if (currentValue._type === "EntitySet" && currentValue.entityType) {
            currentPath = combinePath(currentValue.entityType, pathPart);
        }
        else if (currentValue._type === "NavigationProperty" && currentValue.targetTypeName) {
            currentPath = combinePath(currentValue.targetTypeName, pathPart);
        }
        else if (currentValue._type === "NavigationProperty" && currentValue.targetType) {
            currentPath = combinePath(currentValue.targetType.fullyQualifiedName, pathPart);
        }
        else if (currentValue._type === "Property") {
            currentPath = combinePath(currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")), pathPart);
        }
        else if (currentValue._type === "Action" && currentValue.isBound) {
            currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            if (!objectMap[currentPath]) {
                currentPath = combinePath(currentValue.sourceType, pathPart);
            }
        }
        else if (currentValue._type === "ActionParameter" && currentValue.isEntitySet) {
            currentPath = combinePath(currentValue.type, pathPart);
        }
        else if (currentValue._type === "ActionParameter" && !currentValue.isEntitySet) {
            currentPath = combinePath(currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")), pathPart);
            if (!objectMap[currentPath]) {
                var lastIdx = currentTarget.fullyQualifiedName.lastIndexOf("/");
                if (lastIdx === -1) {
                    lastIdx = currentTarget.fullyQualifiedName.length;
                }
                currentPath = combinePath(objectMap[currentTarget.fullyQualifiedName.substr(0, lastIdx)].sourceType, pathPart);
            }
        }
        else {
            currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            if (currentValue[pathPart] !== undefined) {
                return currentValue[pathPart];
            }
            else if (pathPart === "$AnnotationPath" && currentValue.$target) {
                return currentValue.$target;
            }
        }
        return objectMap[currentPath];
    }, null);
    if (!target) {
        // console.log("Missing target " + path);
    }
    if (pathOnly) {
        return currentPath;
    }
    return target;
}
function isAnnotationPath(pathStr) {
    return pathStr.indexOf("@") !== -1;
}
function parseValue(propertyValue, valueFQN, parserOutput, currentTarget, objectMap, toResolve) {
    if (propertyValue === undefined) {
        return undefined;
    }
    switch (propertyValue.type) {
        case "String":
            return propertyValue.String;
        case "Int":
            return propertyValue.Int;
        case "Bool":
            return propertyValue.Bool;
        case "Decimal":
            return propertyValue.Decimal;
        case "Date":
            return propertyValue.Date;
        case "EnumMember":
            return propertyValue.EnumMember;
        case "PropertyPath":
            return {
                type: "PropertyPath",
                value: propertyValue.PropertyPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(objectMap, currentTarget, propertyValue.PropertyPath)
            };
        case "NavigationPropertyPath":
            return {
                type: "NavigationPropertyPath",
                value: propertyValue.NavigationPropertyPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(objectMap, currentTarget, propertyValue.NavigationPropertyPath)
            };
        case "AnnotationPath":
            var annotationTarget = resolveTarget(objectMap, currentTarget, unalias(parserOutput.references, propertyValue.AnnotationPath), true);
            var annotationPath = {
                type: "AnnotationPath",
                value: propertyValue.AnnotationPath,
                fullyQualifiedName: valueFQN,
                $target: annotationTarget
            };
            toResolve.push(annotationPath);
            return annotationPath;
        case "Path":
            if (isAnnotationPath(propertyValue.Path)) {
                // If it's an anntoation that we can resolve, resolve it !
                var $target_1 = resolveTarget(objectMap, currentTarget, propertyValue.Path);
                if ($target_1) {
                    return $target_1;
                }
            }
            var $target = resolveTarget(objectMap, currentTarget, propertyValue.Path, true);
            var path = new Path(propertyValue, $target);
            toResolve.push(path);
            return path;
        case "Record":
            return parseRecord(propertyValue.Record, valueFQN, parserOutput, currentTarget, objectMap, toResolve);
        case "Collection":
            return parseCollection(propertyValue.Collection, valueFQN, parserOutput, currentTarget, objectMap, toResolve);
        case "Apply":
            return propertyValue;
    }
}
function parseRecord(recordDefinition, currentFQN, parserOutput, currentTarget, objectMap, toResolve) {
    var annotationTerm = {
        $Type: unalias(parserOutput.references, recordDefinition.type),
        fullyQualifiedName: currentFQN
    };
    var annotationContent = {};
    recordDefinition.propertyValues.forEach(function (propertyValue) {
        annotationContent[propertyValue.name] = parseValue(propertyValue.value, currentFQN + "/" + propertyValue.name, parserOutput, currentTarget, objectMap, toResolve);
        if (annotationContent.hasOwnProperty("Action") &&
            (annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
                annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")) {
            if (currentTarget.actions) {
                annotationContent.ActionTarget = currentTarget.actions[annotationContent.Action];
                if (!annotationContent.ActionTarget) {
                    // Add to diagnostics debugger;
                }
            }
        }
    });
    return Object.assign(annotationTerm, annotationContent);
}
function parseCollection(collectionDefinition, parentFQN, parserOutput, currentTarget, objectMap, toResolve) {
    switch (collectionDefinition.type) {
        case "PropertyPath":
            return collectionDefinition.map(function (propertyPath, propertyIdx) {
                return {
                    type: "PropertyPath",
                    value: propertyPath.PropertyPath,
                    fullyQualifiedName: parentFQN + "/" + propertyIdx,
                    $target: resolveTarget(objectMap, currentTarget, propertyPath.PropertyPath)
                };
            });
        case "Path":
            return collectionDefinition.map(function (pathValue) {
                if (isAnnotationPath(pathValue.Path)) {
                    // If it's an anntoation that we can resolve, resolve it !
                    var $target_2 = resolveTarget(objectMap, currentTarget, pathValue.Path);
                    if ($target_2) {
                        return $target_2;
                    }
                }
                var $target = resolveTarget(objectMap, currentTarget, pathValue.Path, true);
                var path = new Path(pathValue, $target);
                toResolve.push(path);
                return path;
            });
        case "AnnotationPath":
            return collectionDefinition.map(function (annotationPath, annotationIdx) {
                var annotationTarget = resolveTarget(objectMap, currentTarget, annotationPath.AnnotationPath, true);
                var annotationCollectionElement = {
                    type: "AnnotationPath",
                    value: annotationPath.AnnotationPath,
                    fullyQualifiedName: parentFQN + "/" + annotationIdx,
                    $target: annotationTarget
                };
                toResolve.push(annotationCollectionElement);
                return annotationCollectionElement;
            });
        case "NavigationPropertyPath":
            return collectionDefinition.map(function (navPropertyPath, navPropIdx) {
                return {
                    type: "NavigationPropertyPath",
                    value: navPropertyPath.NavigationPropertyPath,
                    fullyQualifiedName: parentFQN + "/" + navPropIdx,
                    $target: resolveTarget(objectMap, currentTarget, navPropertyPath.NavigationPropertyPath)
                };
            });
        case "Record":
            return collectionDefinition.map(function (recordDefinition, recordIdx) {
                return parseRecord(recordDefinition, parentFQN + "/" + recordIdx, parserOutput, currentTarget, objectMap, toResolve);
            });
        case "String":
            return collectionDefinition.map(function (stringValue) {
                return stringValue;
            });
        default:
            if (collectionDefinition.length === 0) {
                return [];
            }
            throw new Error("Unsupported case");
    }
}
function convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve) {
    if (annotation.record) {
        var annotationTerm_1 = {
            $Type: unalias(parserOutput.references, annotation.record.type),
            fullyQualifiedName: annotation.fullyQualifiedName,
            qualifier: annotation.qualifier
        };
        var annotationContent_1 = {};
        annotation.record.propertyValues.forEach(function (propertyValue) {
            annotationContent_1[propertyValue.name] = parseValue(propertyValue.value, annotation.fullyQualifiedName + "/" + propertyValue.name, parserOutput, currentTarget, objectMap, toResolve);
            if (annotationContent_1.hasOwnProperty("Action") &&
                (!annotation.record ||
                    annotationTerm_1.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
                    annotationTerm_1.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")) {
                if (currentTarget.actions) {
                    annotationContent_1.ActionTarget = currentTarget.actions[annotationContent_1.Action];
                    if (!annotationContent_1.ActionTarget) {
                        // Add to diagnostics
                        // debugger;
                    }
                }
            }
        });
        return Object.assign(annotationTerm_1, annotationContent_1);
    }
    else if (annotation.collection === undefined) {
        if (annotation.value) {
            return parseValue(annotation.value, annotation.fullyQualifiedName, parserOutput, currentTarget, objectMap, toResolve);
        }
        else {
            return true;
        }
    }
    else if (annotation.collection) {
        var collection = parseCollection(annotation.collection, annotation.fullyQualifiedName, parserOutput, currentTarget, objectMap, toResolve);
        collection.fullyQualifiedName = annotation.fullyQualifiedName;
        return collection;
    }
    else {
        throw new Error("Unsupported case");
    }
}
function createResolvePathFn(entityType, objectMap) {
    return function (relativePath) {
        return resolveTarget(objectMap, entityType, relativePath);
    };
}
function resolveNavigationProperties(entityTypes, associations, objectMap) {
    entityTypes.forEach(function (entityType) {
        entityType.navigationProperties.forEach(function (navProp) {
            if (navProp.targetTypeName) {
                navProp.targetType =
                    objectMap[navProp.targetTypeName];
            }
            else if (navProp.relationship) {
                var targetAssociation = associations.find(function (association) { return association.fullyQualifiedName === navProp.relationship; });
                if (targetAssociation) {
                    var associationEnd = targetAssociation.associationEnd.find(function (end) { return end.role === navProp.toRole; });
                    if (associationEnd) {
                        navProp.targetType = objectMap[associationEnd.type];
                    }
                }
            }
        });
        entityType.resolvePath = createResolvePathFn(entityType, objectMap);
    });
}
function linkActionsToEntityType(namespace, actions, objectMap) {
    actions.forEach(function (action) {
        if (action.isBound) {
            var sourceEntityType = objectMap[action.sourceType];
            action.sourceEntityType = sourceEntityType;
            if (sourceEntityType) {
                if (!sourceEntityType.actions) {
                    sourceEntityType.actions = {};
                }
                sourceEntityType.actions[action.name] = action;
                sourceEntityType.actions[namespace + "." + action.name] = action;
            }
            var returnEntityType = objectMap[action.returnType];
            action.returnEntityType = returnEntityType;
        }
    });
}
function linkEntityTypeToEntitySet(entitySets, objectMap) {
    entitySets.forEach(function (entitySet) {
        entitySet.entityType = objectMap[entitySet.entityTypeName];
        if (!entitySet.annotations) {
            entitySet.annotations = {};
        }
        if (!entitySet.entityType.annotations) {
            entitySet.entityType.annotations = {};
        }
    });
}
function convertTypes(parserOutput) {
    var objectMap = buildObjectMap(parserOutput);
    resolveNavigationProperties(parserOutput.schema.entityTypes, parserOutput.schema.associations, objectMap);
    linkActionsToEntityType(parserOutput.schema.namespace, parserOutput.schema.actions, objectMap);
    linkEntityTypeToEntitySet(parserOutput.schema.entitySets, objectMap);
    var toResolve = [];
    var unresolvedAnnotations = [];
    Object.keys(parserOutput.schema.annotations).forEach(function (annotationSource) {
        parserOutput.schema.annotations[annotationSource].forEach(function (annotationList) {
            var currentTargetName = unalias(parserOutput.references, annotationList.target);
            var currentTarget = objectMap[currentTargetName];
            if (!currentTarget) {
                if (currentTargetName.indexOf("@") !== -1) {
                    unresolvedAnnotations.push(annotationList);
                }
            }
            else if (typeof currentTarget === "object") {
                if (!currentTarget.annotations) {
                    currentTarget.annotations = {};
                }
                annotationList.annotations.forEach(function (annotation) {
                    var _a = annotation.term.split("."), vocAlias = _a[0], vocTerm = _a[1];
                    if (!currentTarget.annotations[vocAlias]) {
                        currentTarget.annotations[vocAlias] = {};
                    }
                    if (!currentTarget.annotations._annotations) {
                        currentTarget.annotations._annotations = {};
                    }
                    var vocTermWithQualifier = "" + vocTerm + (annotation.qualifier ? "#" + annotation.qualifier : "");
                    currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve);
                    if (currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
                        typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object") {
                        currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(parserOutput.references, vocAlias + "." + vocTerm);
                        currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
                    }
                    currentTarget.annotations._annotations[vocAlias + "." + vocTermWithQualifier] =
                        currentTarget.annotations[vocAlias][vocTermWithQualifier];
                    objectMap[currentTargetName + "@" + unalias(parserOutput.references, vocAlias + "." + vocTermWithQualifier)] = currentTarget.annotations[vocAlias][vocTermWithQualifier];
                });
            }
            else {
                debugger;
            }
        });
    });
    unresolvedAnnotations.forEach(function (annotationList) {
        var currentTargetName = unalias(parserOutput.references, annotationList.target);
        var _a = currentTargetName.split("@"), baseObj = _a[0], annotationPart = _a[1];
        var targetSplit = annotationPart.split("/");
        baseObj = baseObj + "@" + targetSplit[0];
        var currentTarget = targetSplit.slice(1).reduce(function (currentObj, path) {
            if (!currentObj) {
                return null;
            }
            return currentObj[path];
        }, objectMap[baseObj]);
        if (!currentTarget) {
            // console.log("Missing target again " + currentTargetName);
        }
        else if (typeof currentTarget === "object") {
            if (!currentTarget.annotations) {
                currentTarget.annotations = {};
            }
            annotationList.annotations.forEach(function (annotation) {
                var _a = annotation.term.split("."), vocAlias = _a[0], vocTerm = _a[1];
                if (!currentTarget.annotations[vocAlias]) {
                    currentTarget.annotations[vocAlias] = {};
                }
                if (!currentTarget.annotations._annotations) {
                    currentTarget.annotations._annotations = {};
                }
                var vocTermWithQualifier = "" + vocTerm + (annotation.qualifier ? "#" + annotation.qualifier : "");
                currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve);
                if (currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
                    typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object") {
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(parserOutput.references, vocAlias + "." + vocTerm);
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
                }
                currentTarget.annotations._annotations[vocAlias + "." + vocTermWithQualifier] =
                    currentTarget.annotations[vocAlias][vocTermWithQualifier];
                objectMap[currentTargetName + "@" + unalias(parserOutput.references, vocAlias + "." + vocTermWithQualifier)] = currentTarget.annotations[vocAlias][vocTermWithQualifier];
            });
        }
        else {
            debugger;
        }
    });
    toResolve.forEach(function (resolveable) {
        var targetStr = resolveable.$target;
        resolveable.$target = objectMap[targetStr];
    });
    parserOutput.entitySets = parserOutput.schema.entitySets;
    return {
        version: parserOutput.version,
        annotations: parserOutput.schema.annotations,
        namespace: parserOutput.schema.namespace,
        actions: parserOutput.schema.actions,
        entitySets: parserOutput.schema.entitySets,
        entityTypes: parserOutput.schema.entityTypes,
        references: parserOutput.references
    };
}
exports.convertTypes = convertTypes;
function transformCollectionItemToGenericType(collectionItem) {
    if (typeof collectionItem === "string") {
        return collectionItem;
    }
    else if (typeof collectionItem === "object") {
        if (collectionItem.hasOwnProperty("$Type")) {
            // Annotation Record
            var outItem_1 = {
                type: collectionItem.$Type,
                propertyValues: []
            };
            // Could validate keys and type based on $Type
            Object.keys(collectionItem).forEach(function (collectionKey) {
                if (collectionKey !== "$Type" &&
                    collectionKey !== "term" &&
                    collectionKey !== "qualifier" &&
                    collectionKey !== "ActionTarget" &&
                    collectionKey !== "fullyQualifiedName") {
                    var value = collectionItem[collectionKey];
                    if (typeof value === "string") {
                        outItem_1.propertyValues.push({
                            name: collectionKey,
                            value: {
                                type: "String",
                                String: value
                            }
                        });
                    }
                    else if (typeof value === "boolean") {
                        outItem_1.propertyValues.push({
                            name: collectionKey,
                            value: {
                                type: "Bool",
                                Bool: value
                            }
                        });
                    }
                    else if (value.type === "Path") {
                        outItem_1.propertyValues.push({
                            name: collectionKey,
                            value: {
                                type: "Path",
                                Path: value.path
                            }
                        });
                    }
                    else if (value.type === "AnnotationPath") {
                        outItem_1.propertyValues.push({
                            name: collectionKey,
                            value: {
                                type: "AnnotationPath",
                                AnnotationPath: value.value
                            }
                        });
                    }
                    else if (value.type === "PropertyPath") {
                        outItem_1.propertyValues.push({
                            name: collectionKey,
                            value: {
                                type: "PropertyPath",
                                PropertyPath: value.value
                            }
                        });
                    }
                    else if (value.type === "NavigationPropertyPath") {
                        outItem_1.propertyValues.push({
                            name: collectionKey,
                            value: {
                                type: "NavigationPropertyPath",
                                NavigationPropertyPath: value.value
                            }
                        });
                    }
                    else if (value.hasOwnProperty("$Type")) {
                        outItem_1.propertyValues.push({
                            name: collectionKey,
                            value: {
                                type: "Record",
                                Record: transformCollectionItemToGenericType(value)
                            }
                        });
                    }
                }
            });
            return outItem_1;
        }
    }
}
function transformTermToGenericType(annotation) {
    var baseAnnotation = {
        term: annotation.term,
        qualifier: annotation.qualifier
    };
    if (Array.isArray(annotation)) {
        // Collection
        return __assign(__assign({}, baseAnnotation), { collection: annotation.map(transformCollectionItemToGenericType) });
    }
    else if (annotation.hasOwnProperty("$Type")) {
        return __assign(__assign({}, baseAnnotation), { record: transformCollectionItemToGenericType(annotation) });
    }
    else {
        return baseAnnotation;
    }
}
exports.transformTermToGenericType = transformTermToGenericType;
