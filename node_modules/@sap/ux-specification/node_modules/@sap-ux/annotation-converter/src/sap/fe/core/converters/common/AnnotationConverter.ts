import {
	Annotation as EdmAnnotation,
	AnnotationList,
	AnnotationRecord,
	AnnotationTerm,
	ComplexType,
	ConverterOutput,
	Expression,
	ParserOutput,
	PathExpression,
	PropertyPath,
	PropertyValue,
	AnnotationPathExpression,
	NavigationPropertyPathExpression,
	PropertyPathExpression
} from "@sap-ux/vocabularies-types";
import { Association, Reference } from "@sap-ux/vocabularies-types/dist/Parser";
import {
	Annotation,
	EntityType,
	V4NavigationProperty,
	V2NavigationProperty,
	Action,
	EntitySet
} from "@sap-ux/vocabularies-types/dist/Converter";

class Path {
	path: string;
	$target: string;
	type: string;

	constructor(pathExpression: PathExpression, targetName: string) {
		this.path = pathExpression.Path;
		this.type = "Path";
		this.$target = targetName;
	}
}

type ReferencesWithMap = Reference[] & {
	referenceMap?: Record<string, Reference>;
};

function unalias(references: ReferencesWithMap, aliasedValue: string | undefined): string | undefined {
	if (!references.referenceMap) {
		references.referenceMap = references.reduce((map: Record<string, Reference>, reference) => {
			map[reference.alias] = reference;
			return map;
		}, {});
	}
	if (!aliasedValue) {
		return aliasedValue;
	}
	const [alias, value] = aliasedValue.split(".");
	const reference = references.referenceMap[alias];
	if (reference) {
		return `${reference.namespace}.${value}`;
	} else {
		// Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
		if (aliasedValue.indexOf("@") !== -1) {
			const [preAlias, postAlias] = aliasedValue.split("@");
			return `${preAlias}@${unalias(references, postAlias)}`;
		} else {
			return aliasedValue;
		}
	}
}

function buildObjectMap(parserOutput: ParserOutput): Record<string, any> {
	const objectMap: any = {};
	if (parserOutput.schema.entityContainer && parserOutput.schema.entityContainer.fullyQualifiedName) {
		objectMap[parserOutput.schema.entityContainer.fullyQualifiedName] = parserOutput.schema.entityContainer;
	}
	parserOutput.schema.entitySets.forEach(entitySet => {
		objectMap[entitySet.fullyQualifiedName] = entitySet;
	});
	parserOutput.schema.actions.forEach(action => {
		objectMap[action.fullyQualifiedName] = action;
		action.parameters.forEach(parameter => {
			objectMap[parameter.fullyQualifiedName] = parameter;
		});
	});
	parserOutput.schema.entityTypes.forEach(entityType => {
		objectMap[entityType.fullyQualifiedName] = entityType;
		entityType.entityProperties.forEach(property => {
			objectMap[property.fullyQualifiedName] = property;
		});
		entityType.navigationProperties.forEach(navProperty => {
			objectMap[navProperty.fullyQualifiedName] = navProperty;
		});
	});
	Object.keys(parserOutput.schema.annotations).forEach(annotationSource => {
		parserOutput.schema.annotations[annotationSource].forEach(annotationList => {
			const currentTargetName = unalias(parserOutput.references, annotationList.target);
			annotationList.annotations.forEach(annotation => {
				let annotationFQN = `/${currentTargetName}@${unalias(parserOutput.references, annotation.term)}`;
				if (annotation.qualifier) {
					annotationFQN += `#${annotation.qualifier}`;
				}
				objectMap[annotationFQN] = annotation;
				(annotation as Annotation).fullyQualifiedName = annotationFQN;
			});
		});
	});
	return objectMap;
}

function combinePath(currentTarget: string, path: string): string {
	if (path.startsWith("@")) {
		return currentTarget + path;
	} else {
		return currentTarget + "/" + path;
	}
}

function resolveTarget(objectMap: any, currentTarget: any, path: string, pathOnly: boolean = false) {
	if (!path) {
		return undefined;
	}
	path = combinePath(currentTarget.fullyQualifiedName, path);

	const pathSplit = path.split("/");
	let currentPath = path;
	const target = pathSplit.reduce((currentValue: any, pathPart) => {
		if (!currentValue) {
			currentPath = pathPart;
		} else if (currentValue._type === "EntitySet" && currentValue.entityType) {
			currentPath = combinePath(currentValue.entityType, pathPart);
		} else if (currentValue._type === "NavigationProperty" && currentValue.targetTypeName) {
			currentPath = combinePath(currentValue.targetTypeName, pathPart);
		} else if (currentValue._type === "NavigationProperty" && currentValue.targetType) {
			currentPath = combinePath(currentValue.targetType.fullyQualifiedName, pathPart);
		} else if (currentValue._type === "Property") {
			currentPath = combinePath(
				currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")),
				pathPart
			);
		} else if (currentValue._type === "Action" && currentValue.isBound) {
			currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
			if (!objectMap[currentPath]) {
				currentPath = combinePath(currentValue.sourceType, pathPart);
			}
		} else if (currentValue._type === "ActionParameter" && currentValue.isEntitySet) {
			currentPath = combinePath(currentValue.type, pathPart);
		} else if (currentValue._type === "ActionParameter" && !currentValue.isEntitySet) {
			currentPath = combinePath(
				currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")),
				pathPart
			);
			if (!objectMap[currentPath]) {
				let lastIdx = currentTarget.fullyQualifiedName.lastIndexOf("/");
				if (lastIdx === -1) {
					lastIdx = currentTarget.fullyQualifiedName.length;
				}
				currentPath = combinePath(
					(objectMap[currentTarget.fullyQualifiedName.substr(0, lastIdx)] as Action).sourceType,
					pathPart
				);
			}
		} else {
			currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
			if (currentValue[pathPart] !== undefined) {
				return currentValue[pathPart];
			} else if (pathPart === "$AnnotationPath" && currentValue.$target) {
				return currentValue.$target;
			}
		}
		return objectMap[currentPath];
	}, null);
	if (!target) {
		// console.log("Missing target " + path);
	}
	if (pathOnly) {
		return currentPath;
	}
	return target;
}

function isAnnotationPath(pathStr: string): boolean {
	return pathStr.indexOf("@") !== -1;
}

function parseValue(
	propertyValue: Expression,
	valueFQN: string,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[]
) {
	if (propertyValue === undefined) {
		return undefined;
	}
	switch (propertyValue.type) {
		case "String":
			return propertyValue.String;
		case "Int":
			return propertyValue.Int;
		case "Bool":
			return propertyValue.Bool;
		case "Decimal":
			return propertyValue.Decimal;
		case "Date":
			return propertyValue.Date;
		case "EnumMember":
			return propertyValue.EnumMember;
		case "PropertyPath":
			return {
				type: "PropertyPath",
				value: propertyValue.PropertyPath,
				fullyQualifiedName: valueFQN,
				$target: resolveTarget(objectMap, currentTarget, propertyValue.PropertyPath)
			};
		case "NavigationPropertyPath":
			return {
				type: "NavigationPropertyPath",
				value: propertyValue.NavigationPropertyPath,
				fullyQualifiedName: valueFQN,
				$target: resolveTarget(objectMap, currentTarget, propertyValue.NavigationPropertyPath)
			};
		case "AnnotationPath":
			const annotationTarget = resolveTarget(
				objectMap,
				currentTarget,
				unalias(parserOutput.references, propertyValue.AnnotationPath) as string,
				true
			);
			const annotationPath = {
				type: "AnnotationPath",
				value: propertyValue.AnnotationPath,
				fullyQualifiedName: valueFQN,
				$target: annotationTarget
			};
			toResolve.push(annotationPath);
			return annotationPath;
		case "Path":
			if (isAnnotationPath(propertyValue.Path)) {
				// If it's an anntoation that we can resolve, resolve it !
				const $target = resolveTarget(objectMap, currentTarget, propertyValue.Path);
				if ($target) {
					return $target;
				}
			}
			const $target = resolveTarget(objectMap, currentTarget, propertyValue.Path, true);
			const path = new Path(propertyValue, $target);
			toResolve.push(path);
			return path;

		case "Record":
			return parseRecord(propertyValue.Record, valueFQN, parserOutput, currentTarget, objectMap, toResolve);
		case "Collection":
			return parseCollection(
				propertyValue.Collection,
				valueFQN,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve
			);
		case "Apply":
			return propertyValue;
	}
}

function parseRecord(
	recordDefinition: AnnotationRecord,
	currentFQN: string,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[]
) {
	const annotationTerm: any = {
		$Type: unalias(parserOutput.references, recordDefinition.type),
		fullyQualifiedName: currentFQN
	};
	const annotationContent: any = {};
	recordDefinition.propertyValues.forEach((propertyValue: PropertyValue) => {
		annotationContent[propertyValue.name] = parseValue(
			propertyValue.value,
			`${currentFQN}/${propertyValue.name}`,
			parserOutput,
			currentTarget,
			objectMap,
			toResolve
		);
		if (
			annotationContent.hasOwnProperty("Action") &&
			(annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
				annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")
		) {
			if (currentTarget.actions) {
				annotationContent.ActionTarget = currentTarget.actions[annotationContent.Action];
				if (!annotationContent.ActionTarget) {
					// Add to diagnostics debugger;
				}
			}
		}
	});
	return Object.assign(annotationTerm, annotationContent);
}

function parseCollection(
	collectionDefinition: any[],
	parentFQN: string,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[]
) {
	switch ((collectionDefinition as any).type) {
		case "PropertyPath":
			return collectionDefinition.map((propertyPath, propertyIdx) => {
				return {
					type: "PropertyPath",
					value: propertyPath.PropertyPath,
					fullyQualifiedName: `${parentFQN}/${propertyIdx}`,
					$target: resolveTarget(objectMap, currentTarget, propertyPath.PropertyPath)
				};
			});
		case "Path":
			return collectionDefinition.map(pathValue => {
				if (isAnnotationPath(pathValue.Path)) {
					// If it's an anntoation that we can resolve, resolve it !
					const $target = resolveTarget(objectMap, currentTarget, pathValue.Path);
					if ($target) {
						return $target;
					}
				}
				const $target = resolveTarget(objectMap, currentTarget, pathValue.Path, true);
				const path = new Path(pathValue, $target);
				toResolve.push(path);
				return path;
			});
		case "AnnotationPath":
			return collectionDefinition.map((annotationPath, annotationIdx) => {
				const annotationTarget = resolveTarget(objectMap, currentTarget, annotationPath.AnnotationPath, true);
				const annotationCollectionElement = {
					type: "AnnotationPath",
					value: annotationPath.AnnotationPath,
					fullyQualifiedName: `${parentFQN}/${annotationIdx}`,
					$target: annotationTarget
				};
				toResolve.push(annotationCollectionElement);
				return annotationCollectionElement;
			});
		case "NavigationPropertyPath":
			return collectionDefinition.map((navPropertyPath, navPropIdx) => {
				return {
					type: "NavigationPropertyPath",
					value: navPropertyPath.NavigationPropertyPath,
					fullyQualifiedName: `${parentFQN}/${navPropIdx}`,
					$target: resolveTarget(objectMap, currentTarget, navPropertyPath.NavigationPropertyPath)
				};
			});
		case "Record":
			return collectionDefinition.map((recordDefinition, recordIdx) => {
				return parseRecord(
					recordDefinition,
					`${parentFQN}/${recordIdx}`,
					parserOutput,
					currentTarget,
					objectMap,
					toResolve
				);
			});
		case "String":
			return collectionDefinition.map(stringValue => {
				return stringValue;
			});
		default:
			if (collectionDefinition.length === 0) {
				return [];
			}
			throw new Error("Unsupported case");
	}
}

type Resolveable = {
	$target: string;
};

function convertAnnotation(
	annotation: Annotation,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[]
): any {
	if (annotation.record) {
		const annotationTerm: any = {
			$Type: unalias(parserOutput.references, annotation.record.type),
			fullyQualifiedName: annotation.fullyQualifiedName,
			qualifier: annotation.qualifier
		};
		const annotationContent: any = {};
		annotation.record.propertyValues.forEach((propertyValue: PropertyValue) => {
			annotationContent[propertyValue.name] = parseValue(
				propertyValue.value,
				`${annotation.fullyQualifiedName}/${propertyValue.name}`,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve
			);
			if (
				annotationContent.hasOwnProperty("Action") &&
				(!annotation.record ||
					annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
					annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")
			) {
				if (currentTarget.actions) {
					annotationContent.ActionTarget = currentTarget.actions[annotationContent.Action];
					if (!annotationContent.ActionTarget) {
						// Add to diagnostics
						// debugger;
					}
				}
			}
		});
		return Object.assign(annotationTerm, annotationContent);
	} else if (annotation.collection === undefined) {
		if (annotation.value) {
			return parseValue(
				annotation.value,
				annotation.fullyQualifiedName,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve
			);
		} else {
			return true;
		}
	} else if (annotation.collection) {
		const collection: any = parseCollection(
			annotation.collection,
			annotation.fullyQualifiedName,
			parserOutput,
			currentTarget,
			objectMap,
			toResolve
		);
		collection.fullyQualifiedName = annotation.fullyQualifiedName;
		return collection;
	} else {
		throw new Error("Unsupported case");
	}
}

function createResolvePathFn(entityType: EntityType, objectMap: Record<string, any>) {
	return function(relativePath: string): any {
		return resolveTarget(objectMap, entityType, relativePath);
	};
}

function resolveNavigationProperties(
	entityTypes: EntityType[],
	associations: Association[],
	objectMap: Record<string, any>
): void {
	entityTypes.forEach(entityType => {
		entityType.navigationProperties.forEach(navProp => {
			if ((navProp as V4NavigationProperty).targetTypeName) {
				(navProp as V4NavigationProperty).targetType =
					objectMap[(navProp as V4NavigationProperty).targetTypeName];
			} else if ((navProp as V2NavigationProperty).relationship) {
				const targetAssociation = associations.find(
					association => association.fullyQualifiedName === (navProp as V2NavigationProperty).relationship
				);
				if (targetAssociation) {
					const associationEnd = targetAssociation.associationEnd.find(
						end => end.role === (navProp as V2NavigationProperty).toRole
					);
					if (associationEnd) {
						(navProp as V2NavigationProperty).targetType = objectMap[associationEnd.type];
					}
				}
			}
		});
		entityType.resolvePath = createResolvePathFn(entityType as EntityType, objectMap);
	});
}

function linkActionsToEntityType(namespace: string, actions: Action[], objectMap: Record<string, any>): void {
	actions.forEach(action => {
		if (action.isBound) {
			const sourceEntityType = objectMap[action.sourceType];
			action.sourceEntityType = sourceEntityType;
			if (sourceEntityType) {
				if (!sourceEntityType.actions) {
					sourceEntityType.actions = {};
				}
				sourceEntityType.actions[action.name] = action;
				sourceEntityType.actions[`${namespace}.${action.name}`] = action;
			}
			const returnEntityType = objectMap[action.returnType];
			action.returnEntityType = returnEntityType;
		}
	});
}

function linkEntityTypeToEntitySet(entitySets: EntitySet[], objectMap: Record<string, any>): void {
	entitySets.forEach(entitySet => {
		entitySet.entityType = objectMap[entitySet.entityTypeName];
		if (!entitySet.annotations) {
			entitySet.annotations = {};
		}
		if (!entitySet.entityType.annotations) {
			entitySet.entityType.annotations = {};
		}
	});
}

export function convertTypes(parserOutput: ParserOutput): ConverterOutput {
	const objectMap = buildObjectMap(parserOutput);
	resolveNavigationProperties(
		parserOutput.schema.entityTypes as EntityType[],
		parserOutput.schema.associations,
		objectMap
	);
	linkActionsToEntityType(parserOutput.schema.namespace, parserOutput.schema.actions as Action[], objectMap);
	linkEntityTypeToEntitySet(parserOutput.schema.entitySets as EntitySet[], objectMap);
	const toResolve: Resolveable[] = [];
	const unresolvedAnnotations: AnnotationList[] = [];
	Object.keys(parserOutput.schema.annotations).forEach(annotationSource => {
		parserOutput.schema.annotations[annotationSource].forEach(annotationList => {
			const currentTargetName = unalias(parserOutput.references, annotationList.target) as string;
			const currentTarget = objectMap[currentTargetName];
			if (!currentTarget) {
				if (currentTargetName.indexOf("@") !== -1) {
					unresolvedAnnotations.push(annotationList);
				}
			} else if (typeof currentTarget === "object") {
				if (!currentTarget.annotations) {
					currentTarget.annotations = {};
				}
				annotationList.annotations.forEach(annotation => {
					const [vocAlias, vocTerm] = annotation.term.split(".");
					if (!currentTarget.annotations[vocAlias]) {
						currentTarget.annotations[vocAlias] = {};
					}
					if (!currentTarget.annotations._annotations) {
						currentTarget.annotations._annotations = {};
					}

					const vocTermWithQualifier = `${vocTerm}${annotation.qualifier ? `#${annotation.qualifier}` : ""}`;
					currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(
						annotation as Annotation,
						parserOutput,
						currentTarget,
						objectMap,
						toResolve
					);
					if (
						currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
						typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object"
					) {
						currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(
							parserOutput.references,
							`${vocAlias}.${vocTerm}`
						);
						currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
					}
					currentTarget.annotations._annotations[`${vocAlias}.${vocTermWithQualifier}`] =
						currentTarget.annotations[vocAlias][vocTermWithQualifier];
					objectMap[
						`${currentTargetName}@${unalias(
							parserOutput.references,
							vocAlias + "." + vocTermWithQualifier
						)}`
					] = currentTarget.annotations[vocAlias][vocTermWithQualifier];
				});
			} else {
				debugger;
			}
		});
	});
	unresolvedAnnotations.forEach(annotationList => {
		const currentTargetName = unalias(parserOutput.references, annotationList.target) as string;
		let [baseObj, annotationPart] = currentTargetName.split("@");
		const targetSplit = annotationPart.split("/");
		baseObj = baseObj + "@" + targetSplit[0];
		const currentTarget = targetSplit.slice(1).reduce((currentObj, path) => {
			if (!currentObj) {
				return null;
			}
			return currentObj[path];
		}, objectMap[baseObj]);
		if (!currentTarget) {
			// console.log("Missing target again " + currentTargetName);
		} else if (typeof currentTarget === "object") {
			if (!currentTarget.annotations) {
				currentTarget.annotations = {};
			}
			annotationList.annotations.forEach(annotation => {
				const [vocAlias, vocTerm] = annotation.term.split(".");
				if (!currentTarget.annotations[vocAlias]) {
					currentTarget.annotations[vocAlias] = {};
				}
				if (!currentTarget.annotations._annotations) {
					currentTarget.annotations._annotations = {};
				}

				const vocTermWithQualifier = `${vocTerm}${annotation.qualifier ? `#${annotation.qualifier}` : ""}`;
				currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(
					annotation as Annotation,
					parserOutput,
					currentTarget,
					objectMap,
					toResolve
				);
				if (
					currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
					typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object"
				) {
					currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(
						parserOutput.references,
						`${vocAlias}.${vocTerm}`
					);
					currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
				}
				currentTarget.annotations._annotations[`${vocAlias}.${vocTermWithQualifier}`] =
					currentTarget.annotations[vocAlias][vocTermWithQualifier];
				objectMap[
					`${currentTargetName}@${unalias(parserOutput.references, vocAlias + "." + vocTermWithQualifier)}`
				] = currentTarget.annotations[vocAlias][vocTermWithQualifier];
			});
		} else {
			debugger;
		}
	});
	toResolve.forEach(resolveable => {
		const targetStr = resolveable.$target;
		resolveable.$target = objectMap[targetStr];
	});
	(parserOutput as any).entitySets = parserOutput.schema.entitySets;

	return {
		version: parserOutput.version,
		annotations: parserOutput.schema.annotations,
		namespace: parserOutput.schema.namespace,
		actions: parserOutput.schema.actions as Action[],
		entitySets: parserOutput.schema.entitySets as EntitySet[],
		entityTypes: parserOutput.schema.entityTypes as EntityType[],
		references: parserOutput.references
	};
}

function transformCollectionItemToGenericType(
	collectionItem: any
):
	| AnnotationRecord
	| string
	| PropertyPathExpression
	| PathExpression
	| NavigationPropertyPathExpression
	| AnnotationPathExpression
	| undefined {
	if (typeof collectionItem === "string") {
		return collectionItem;
	} else if (typeof collectionItem === "object") {
		if (collectionItem.hasOwnProperty("$Type")) {
			// Annotation Record
			const outItem = {
				type: collectionItem.$Type,
				propertyValues: [] as any[]
			};
			// Could validate keys and type based on $Type
			Object.keys(collectionItem).forEach(collectionKey => {
				if (
					collectionKey !== "$Type" &&
					collectionKey !== "term" &&
					collectionKey !== "qualifier" &&
					collectionKey !== "ActionTarget" &&
					collectionKey !== "fullyQualifiedName"
				) {
					const value = collectionItem[collectionKey];
					if (typeof value === "string") {
						outItem.propertyValues.push({
							name: collectionKey,
							value: {
								type: "String",
								String: value
							}
						});
					} else if (typeof value === "boolean") {
						outItem.propertyValues.push({
							name: collectionKey,
							value: {
								type: "Bool",
								Bool: value
							}
						});
					} else if (value.type === "Path") {
						outItem.propertyValues.push({
							name: collectionKey,
							value: {
								type: "Path",
								Path: value.path
							}
						});
					} else if (value.type === "AnnotationPath") {
						outItem.propertyValues.push({
							name: collectionKey,
							value: {
								type: "AnnotationPath",
								AnnotationPath: value.value
							}
						});
					} else if (value.type === "PropertyPath") {
						outItem.propertyValues.push({
							name: collectionKey,
							value: {
								type: "PropertyPath",
								PropertyPath: value.value
							}
						});
					} else if (value.type === "NavigationPropertyPath") {
						outItem.propertyValues.push({
							name: collectionKey,
							value: {
								type: "NavigationPropertyPath",
								NavigationPropertyPath: value.value
							}
						});
					} else if (value.hasOwnProperty("$Type")) {
						outItem.propertyValues.push({
							name: collectionKey,
							value: {
								type: "Record",
								Record: transformCollectionItemToGenericType(value)
							}
						});
					}
				}
			});
			return outItem;
		}
	}
}

export function transformTermToGenericType(annotation: AnnotationTerm<any>): EdmAnnotation {
	const baseAnnotation = {
		term: annotation.term,
		qualifier: annotation.qualifier
	};
	if (Array.isArray(annotation)) {
		// Collection
		return {
			...baseAnnotation,
			collection: annotation.map(transformCollectionItemToGenericType) as any[]
		};
	} else if (annotation.hasOwnProperty("$Type")) {
		return { ...baseAnnotation, record: transformCollectionItemToGenericType(annotation) as any };
	} else {
		return baseAnnotation;
	}
}
