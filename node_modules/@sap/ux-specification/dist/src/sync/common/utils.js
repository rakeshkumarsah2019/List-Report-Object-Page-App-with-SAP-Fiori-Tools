"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const common_1 = require("../../specification/common");
const edmx_parser_1 = require("@sap-ux/edmx-parser");
const annotation_converter_1 = require("@sap-ux/annotation-converter");
const schemaAccess_1 = require("../../specification/schemaAccess");
/**
 * Parses, merges, and converts a list of annotation files with aid of tools from annotation-vocabularies-tools
 * @param annotationFiles
 * @returns the typed entity types with annotations
 */
function parseAndMergeAndConvert(annotationFiles) {
    const parseResult = [];
    if (annotationFiles) {
        annotationFiles.forEach(function (annotationData) {
            parseResult.push(edmx_parser_1.parseEDMX(annotationData.fileContent, annotationData.dataSourceUri));
        });
    }
    if (parseResult.length === 0) {
        return;
    }
    return annotation_converter_1.convertTypes(edmx_parser_1.merge(parseResult));
}
exports.parseAndMergeAndConvert = parseAndMergeAndConvert;
exports.getAnnotationPropertyValue = (annotationProperty) => annotationProperty.value || annotationProperty.path;
/**
 * Resolve page section(get key and label->description).
 * @param facetDefinition - the actual annotation record
 * @returns {FacetSection} - object comprising the relevant facet information
 */
function getSectionFacet(facetDefinition) {
    const entityName = facetDefinition.fullyQualifiedName.substr(facetDefinition.fullyQualifiedName.lastIndexOf('@'));
    //Take facet ID as fallback
    let key = facetDefinition.ID ? facetDefinition.ID.toString() : entityName;
    //If reference facet: overwrite with target annotation if present
    if (facetDefinition.$Type !== 'com.sap.vocabularies.UI.v1.CollectionFacet' && 'Target' in facetDefinition) {
        const propertyValue = exports.getAnnotationPropertyValue(facetDefinition.Target);
        const separator = '::';
        const navigationParts = propertyValue.split('/');
        const navigation = navigationParts.length > 1 ? navigationParts[0] : '';
        const uiParts = (navigationParts[1] || navigationParts[0]).split('#');
        const uiClass = uiParts[0];
        const qualifier = uiParts[1] || '';
        key = uiClass.replace('@UI', '@com.sap.vocabularies.UI.v1');
        if (navigation) {
            key = `${navigation}${separator}${key}`;
        }
        if (qualifier) {
            key = `${key}${separator}${qualifier}`;
        }
    }
    key = key.replace(/\//gi, '::');
    return key
        ? {
            key,
            ...(facetDefinition.Label && { label: facetDefinition.Label.toString() }),
            ...(facetDefinition.ID && { ID: facetDefinition.ID.toString() })
        }
        : undefined;
}
exports.getSectionFacet = getSectionFacet;
exports.getManifestSectionByPathV4 = (exportResultManifest, path, targetAnnotation, targetAnnotationEncoded) => {
    let exportResultSection = exportResultManifest;
    path.split('/').forEach(function (element) {
        if (targetAnnotationEncoded && targetAnnotationEncoded === element) {
            element = targetAnnotation;
        }
        if (!exportResultSection[element]) {
            exportResultSection[element] = {};
        }
        exportResultSection = exportResultSection[element];
    });
    return exportResultSection;
};
function replaceAlias(target, service) {
    service.references.forEach((reference) => {
        target = target.replace('@' + reference.alias, '@' + reference.namespace);
    });
    return target;
}
/**
 * The function parses the line item annotation and returns a list of keys, one for each record.
 * It simulates the work of the V2 StableIdHelper, as it calculates the last section of the stable ID.
 * Note: no leading 'template:::TableColumn:::' is added for this last section, for easier reading.
 * This corresponds to the import logic at src/sync/v2/import/controls/table.ts.
 * The string 'template:::TableColumn:::' must be added for flex changes during the export.
 *
 * @param annotationTerm - object of the line item annotation
 * @returns items - Array of keys, each representig the last part of the stable id of a line item record
 */
function getLineItemsTyped(annotationTerm) {
    const items = [];
    let target;
    let value;
    annotationTerm.forEach((lineItemRecord) => {
        let n;
        switch (lineItemRecord.$Type) {
            case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
                value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
                if (value) {
                    items.push(value);
                }
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */:
                value =
                    typeof lineItemRecord.Value === 'string'
                        ? lineItemRecord.Value
                        : exports.getAnnotationPropertyValue(lineItemRecord.Value);
                if (value) {
                    items.push(value);
                }
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
                target = lineItemRecord.Target.value;
                items.push('DataFieldForAnnotation:::sTarget::' +
                    target
                        .replace('@UI', '@com.sap.vocabularies.UI.v1')
                        .replace('@Communication', '@com.sap.vocabularies.Communication.v1')
                        .replace('@Contact', '@com.sap.vocabularies.Contact.v1'));
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */:
                if (lineItemRecord.Inline) {
                    items.push('DataFieldForAction:::sAction::' + lineItemRecord.Action);
                }
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* DataFieldWithIntentBasedNavigation */:
                value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
                items.push('DataFieldWithIntentBasedNavigation:::sProperty::' +
                    value +
                    ':::sSemanticObject::' +
                    lineItemRecord.SemanticObject +
                    ':::sAction::' +
                    lineItemRecord.Action);
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */:
                if (lineItemRecord.Inline) {
                    items.push('DataFieldForIntentBasedNavigation:::sSemanticObject::' +
                        lineItemRecord.SemanticObject +
                        ':::sAction::' +
                        lineItemRecord.Action);
                }
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* DataFieldWithNavigationPath */:
                value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
                target = exports.getAnnotationPropertyValue(lineItemRecord.Target);
                items.push('DataFieldWithNavigationPath:::sProperty::' + value + ':::sTarget::' + target);
                break;
            default:
                break;
        }
    });
    return items;
}
exports.getLineItemsTyped = getLineItemsTyped;
/**
 * Evaluates the target annotation of a reference facet and actualizes the facets for the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 * @param {string} serviceName - name of the service of the app
 * @param {string} entityName - the entity (type) name
 * @param {EntityType[]} entityTypes - entity types, as delivered by parse & merge & convert
 */
function evaluateTargetAnnotation(annotationRecord, facets, serviceName, entityName, entityTypes) {
    const section = getSectionFacet(annotationRecord);
    const path = section.key;
    if (path.includes('com.sap.vocabularies.UI.v1.Chart')) {
        facets[path] = { base: 'ChartFacet' };
    }
    else if (path.includes('com.sap.vocabularies.UI.v1.LineItem')) {
        facets[path] = { base: 'LineItemFacet' };
        const entityType = entityTypes.find((e) => e.fullyQualifiedName === `${serviceName}.${entityName}`);
        if (entityType) {
            const navPath = path.substr(0, path.lastIndexOf('::'));
            const navProp = entityType.navigationProperties.find((n) => n.name === navPath);
            const targetEntity = navProp && navProp['targetType'].fullyQualifiedName;
            const [scope, version, annotation] = path.split('com.sap.vocabularies.')[1].split('.');
            const targetEntityType = entityTypes.find((et) => et.fullyQualifiedName === targetEntity);
            if (targetEntityType &&
                targetEntityType.annotations &&
                targetEntityType.annotations[scope] &&
                targetEntityType.annotations[scope][annotation]) {
                facets[path]['lineItem'] = getLineItemsTyped(targetEntityType.annotations[scope][annotation]);
            }
        }
    }
    else if (path.includes('com.sap.vocabularies.UI.v1.FieldGroup')) {
        facets[path] = { base: 'FormFacet' };
    }
    else {
        return undefined;
    }
    if (annotationRecord.Label) {
        facets[path].Label = annotationRecord.Label;
    }
    // Add Facet ID
    if (annotationRecord.ID) {
        facets[path]['ID'] = annotationRecord.ID;
    }
}
/**
 * Adds the information from facets to the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {EntityType[]} entityTypes - entity types, as delivered by parse & merge & convert
 * @param {string} serviceName - name of the service of the app
 * @param {string} entityName - the entity (type) name
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 */
function addFacetToConfig(annotationRecord, entityTypes, serviceName, entityName, facets) {
    switch (annotationRecord.$Type) {
        case "com.sap.vocabularies.UI.v1.ReferenceFacet" /* ReferenceFacet */: {
            evaluateTargetAnnotation(annotationRecord, facets, serviceName, entityName, entityTypes);
            break;
        }
        case "com.sap.vocabularies.UI.v1.CollectionFacet" /* CollectionFacet */: {
            const section = getSectionFacet(annotationRecord);
            const facet = (facets[section.key] = {
                base: 'CollectionFacet',
                facets: {}
            });
            annotationRecord.Facets.forEach((collectionItem) => {
                addFacetToConfig(collectionItem, entityTypes, serviceName, entityName, facet.facets);
            });
            break;
        }
    }
}
/**
 * Retrieve facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entitySet - the actual entitySet (corresponds to the given page)
 * @param {{Array.<EntityType>}} entityTypes - annotation schema, as delivered by parse & merge & convert
 */
function getObjectPageFacets(entitySet, entityTypes) {
    const facets = {};
    const entityType = entityTypes.find((et) => et.name === entitySet);
    if (!entityType) {
        return;
    }
    const facetAnnotation = entityType.annotations.UI.Facets;
    if (facetAnnotation) {
        const lastDot = entityType.fullyQualifiedName.lastIndexOf('.');
        const serviceName = entityType.fullyQualifiedName.substr(0, lastDot);
        const entityName = entityType.fullyQualifiedName.substr(lastDot + 1);
        // Add facets to configuration
        facetAnnotation.forEach((item) => {
            addFacetToConfig(item, entityTypes, serviceName, entityName, facets);
        });
    }
    return facets;
}
exports.getObjectPageFacets = getObjectPageFacets;
/**
 * Returns the version of Fiori elements (v2/v4) from a given manifest
 * @param manifest - the manifest.json file
 */
function getVersionFromManifest(manifest) {
    if (manifest['sap.ui.generic.app'] || manifest['sap.ovp']) {
        return common_1.FioriElementsVersion.v2;
    }
    else {
        return common_1.FioriElementsVersion.v4;
    }
}
exports.getVersionFromManifest = getVersionFromManifest;
/**
 * Creates a default object for a new section or subsection, and adds the ID as title if present.
 * @param facet Facet configuration, to be analyzed
 * @returns the new section object
 */
function createSectionWithoutProperties(facet) {
    const section = {
        type: 'object',
        properties: {},
        additionalProperties: false
    };
    if (facet && facet.ID) {
        section['title'] = facet.ID;
    }
    return section;
}
exports.createSectionWithoutProperties = createSectionWithoutProperties;
/**
 * Retrieve page section data(so far id/key and label/description).
 * @param {QualifiedName} entitySet The actual entitySet (corresponds to the given page)
 * @param {EntityType[]} entityTypes Entity types, as delivered by parse & merge & convert
 */
function getObjectPageFacetSection(entitySet, entityTypes) {
    const entityType = entityTypes.find((et) => et.name === entitySet);
    const facetAnnotation = entityType.annotations.UI.Facets;
    if (!facetAnnotation) {
        return [];
    }
    return facetAnnotation.reduce(function (result, item) {
        const section = getSectionFacet(item);
        if (section) {
            result.push(section);
        }
        return result;
    }, []);
}
exports.getObjectPageFacetSection = getObjectPageFacetSection;
/**
 * Cleans empty sub-structures from the export result for manifest
 * @param manifest - manifest.json part of the export result
 * @param path  - path in the manifest
 * @param targetAnnotation - target annotation (optional, in case of sections, subsections)
 * @param targetAnnotationEncoded - encoded version of the target annotation, as represented in the manifest
 */
exports.deleteEmptyStructure = (manifest, path, targetAnnotation, targetAnnotationEncoded) => {
    let manifestSection = manifest;
    path.split('/').forEach(function (element) {
        if (element === targetAnnotationEncoded) {
            element = targetAnnotation;
        }
        if (!manifestSection[element]) {
            return;
        }
        if (Object.keys(manifestSection[element]).length === 0) {
            delete manifestSection[element];
            return;
        }
        manifestSection = manifestSection && manifestSection[element];
    });
};
/**
 * Method which returns generic schema file name.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @return {string} File name of generic schema.
 */
const getGenericSchemaFileName = (schemaType) => {
    return `${schemaType}`;
};
/**
 * Method which returns schema file name and path depending on passed schema or page type.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @param {string} [entitySet] Entity set string.
 * @return {SchemaFilePath} File path info.
 */
exports.getSchemaFilePath = (schemaType, entitySet) => {
    const schemaFile = {
        filename: '',
        path: ''
    };
    switch (schemaType) {
        // Application schema
        case schemaAccess_1.SchemaType.Application: {
            // File name
            schemaFile.filename = `App`;
            // Full path
            schemaFile.path = `./${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // List report and object page
        case schemaAccess_1.SchemaType.ListReport:
        case schemaAccess_1.SchemaType.ObjectPage: {
            // File name
            schemaFile.filename = entitySet ? `${schemaType}_${entitySet}` : getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // Other page configs
        default: {
            // File name
            schemaFile.filename = getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
    }
    schemaFile.path += '.json';
    return schemaFile;
};
//# sourceMappingURL=utils.js.map