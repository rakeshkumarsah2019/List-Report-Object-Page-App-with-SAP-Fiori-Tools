"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const appProvider_1 = require("../../../common/appProvider");
const application_1 = require("../../application");
const listReport_1 = require("../pages/listReport");
const objectPage_1 = require("../pages/objectPage");
const common_1 = require("../../../../specification/common");
const utils_1 = require("../utils");
const common_2 = require("../../../common");
const schemaAccess_1 = require("../../../../specification/schemaAccess");
var Constants;
(function (Constants) {
    Constants["OptionalQuery"] = ":?query:";
    Constants["Component"] = "sap/fe/AppComponent";
    Constants["Namespace"] = "sap.fe.templates";
})(Constants = exports.Constants || (exports.Constants = {}));
// Store controller names which should be handled latelly
const unhandledControllers = [];
// Store route associations
let associations = {};
/**
 * Sort in following way
 * 1. string targets first
 * 2. Then sort targets as array by elements count - from lowest to highest(ASC)
 * @param {SapUi5RoutingRoute} route1 - First instance of router to compare.
 * @param {SapUi5RoutingRoute} route2 - Second instance of router to compare.
 * @return {number} Compare result.
 */
function routesSorter(route1, route2) {
    const target1 = route1.target;
    const target2 = route2.target;
    const isT1Array = Array.isArray(target1);
    const isT2Array = Array.isArray(target2);
    if (isT1Array && isT2Array) {
        return target1.length - target2.length;
    }
    if (!isT1Array && !isT2Array) {
        return 0;
    }
    return !isT1Array ? -1 : 1;
}
/**
 * Method to resolve target and return target name as string.
 * Thing is that we can receive target as array of targets and we need detect which target is unique target in that array.
 * @param {SapUi5RoutingRouteTarget} target - Target to resolve.
 * @param {Array<string>} usedTargets - Array of resolved targets(which means that those targets are not unique anymore).
 * @return {string} Resolved unique target namet.
 */
function resolveTarget(target, usedTargets = []) {
    if (!Array.isArray(target)) {
        return target;
    }
    let targetParts = target;
    for (const usedTarget of usedTargets) {
        targetParts = targetParts.filter((targetPart) => !usedTarget.includes(targetPart));
    }
    return targetParts[0];
}
/**
 * Method which populates object with routings routes associations.
 * @param {SapUi5RoutingRoute} routes - Routing routes.
 * @return {object} Map object of association routes.
 */
function populateAssociations(routes) {
    const associations = {};
    routes = routes.concat().sort(routesSorter);
    const resolvedTargets = [];
    for (const route of routes) {
        const parts = route.pattern.split(':')[0].split('/');
        let target;
        if (Array.isArray(route.target)) {
            target = resolveTarget(route.target, resolvedTargets);
            resolvedTargets.push(route.target);
        }
        else {
            target = route.target;
        }
        for (const part of parts) {
            const prop = part.split('(')[0];
            associations[target] = associations[target] ? `${associations[target]}.${prop}` : prop;
        }
    }
    return associations;
}
/**
 * Get Pages(app.json) using received UI5 routing configuration(from manifest.json)
 * @param routing UI5 routing configuration
 */
function getPages(manifest, schemas) {
    const pages = {};
    const routing = manifest['sap.ui5'].routing;
    associations = populateAssociations(routing.routes);
    for (const id in routing.targets) {
        const target = routing.targets[id];
        const pageType = 'viewId' in target
            ? common_1.PageType.CustomPage
            : target.name.endsWith(common_1.PageType.ListReport)
                ? common_1.PageType.ListReport
                : common_1.PageType.ObjectPage;
        const page = {
            pageType: pageType
        };
        // Entity set
        if (target.options) {
            page.entitySet = target.options.settings.entitySet;
        }
        if (target.controlAggregation) {
            page.controlAggregation = target.controlAggregation;
        }
        if (associations[id] && associations[id].indexOf('.') !== -1) {
            const parts = associations[id].split('.');
            page.navigationProperty = parts[parts.length - 1];
        }
        // Custom page's view object
        if ('viewId' in target) {
            // Populate view of custom page
            page.view = {
                id: target.viewId,
                name: target.viewName,
                ...(target.viewLevel && { viewLevel: target.viewLevel }),
                ...(target.title && { title: target.title })
            };
        }
        // Page navigation object
        // Please note that it is moved to end as in result it would be stringified into 'json' file as last property
        if (target.options) {
            if (target.options.settings.variantManagement) {
                page.variantManagement = target.options.settings.variantManagement;
            }
            page.navigation = {};
            for (const name in target.options.settings.navigation) {
                const route = target.options.settings.navigation[name];
                page.navigation[route.detail.route] = associations[route.detail.route];
            }
        }
        else if ('viewId' in target) {
            // There no 'options' for custom page target -
            //    we need check target's controller source for navigation
            const viewParts = target.viewName.split('.');
            unhandledControllers.push(viewParts[viewParts.length - 1]);
        }
        // Get layout from route
        const route = routing.routes.find((route) => route.name === 'BookingObjectPage');
        if (route && 'layout' in route) {
            page.defaultLayoutType = route.layout;
        }
        pages[id] = page;
        const jsonSchema = Object.keys(schemas).find((element) => element.includes(page.pageType));
        // convert settings to config
        if (jsonSchema) {
            page.config =
                page.pageType === common_1.PageType.ListReport
                    ? listReport_1.createListReportConfig(manifest, schemas[jsonSchema])
                    : objectPage_1.createObjectPageConfig(manifest, schemas[jsonSchema], id);
        }
    }
    return pages;
}
/**
 * Get the id of the page that is to open when the application is started.
 * @param routing UI5 routing configuration
 */
function getHome(routing) {
    for (const route of routing.routes) {
        if (route.pattern === Constants.OptionalQuery) {
            return resolveTarget(route.target);
        }
    }
    return resolveTarget(routing.routes[0].target);
}
/**
 * Method which detects app settings from manifest.
 * Currently only one setting is detected -Flexible Column Layout
 * @param routing UI5 routing configuration.
 * @return {AppSettings} Application settings.
 */
function getSettings(routing) {
    return routing.config && routing.config.flexibleColumnLayout
        ? {
            flexibleColumnLayout: routing.config.flexibleColumnLayout
        }
        : undefined;
}
class V4AppProvider extends appProvider_1.AppProvider {
    constructor(manifest, schemas) {
        // Import settings
        const appSettings = new application_1.AppSettings();
        const schemaFile = common_2.getSchemaFilePath(schemaAccess_1.SchemaType.Application);
        utils_1.transferSettingsOfObject(appSettings, manifest, schemas[schemaFile.filename]['definitions']['AppSettings'], '');
        super(manifest, schemas, getHome(manifest['sap.ui5'].routing), getPages(manifest, schemas), common_1.FioriElementsVersion.v4, { ...getSettings(manifest['sap.ui5'].routing), ...appSettings });
        this.unhandledControllers = unhandledControllers;
    }
    /**
     * Public method which receives application controllers content and handles it
     * @param {Controllers} controllers Object which contains string content of controllers
     */
    handleControllers(controllers) {
        for (const name in controllers) {
            const page = this.app.pages[name];
            // Update unhandled controllers array
            const index = this.unhandledControllers.indexOf(name);
            if (index !== -1) {
                this.unhandledControllers.splice(index, 1);
            }
            if (!controllers[name] || !page) {
                // There no content or page does not exist
                continue;
            }
            // We need find does controller have '.navTo' calls and extract first param
            // Currently we expecting that first param would be simple string value
            // Regex to match method 'navTo'
            const matches = controllers[name].match(/[.]navTo[\s(](.*?)[)]/g) || [];
            for (let match of matches) {
                // There is matches for navigation's method call
                // Remove brackets from function call
                match = match.substr(match.indexOf('(') + 1);
                match = match.substring(0, match.length - 1).trim();
                // Find first param
                let firstParam = match.split(',')[0].trim();
                // Remove quotes
                firstParam = firstParam.substr(1, firstParam.length - 2);
                // Populate missing navigation
                if (firstParam && associations[firstParam]) {
                    if (!page.navigation) {
                        page.navigation = {};
                    }
                    page.navigation[firstParam] = associations[firstParam];
                }
            }
        }
    }
}
exports.V4AppProvider = V4AppProvider;
//# sourceMappingURL=appProvider.js.map