"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pages_1 = require("./pages");
const decorators_1 = require("../../common/decoration/decorators");
const controls_1 = require("./controls");
const AnalyticalListPageChart_1 = require("../../../sync/v2/export/controls/AnalyticalListPageChart");
const page_1 = require("../../../specification/common/page");
const v2_1 = require("../../../v2");
const application_1 = require("../application");
const manifest_1 = require("./manifest");
const utils_1 = require("../import/utils");
const Card_1 = require("../../../specification/v2/controls/Card");
const common_1 = require("../../common");
/**
 * Returns a fresh export results object with default values
 */
const getDefaultExportResult = () => ({
    flexChanges: [],
    manifest: {
        'sap.ui.generic.app': { pages: {} }
    }
});
/**
 * Create missing card from the manifest
 * @param key - card name
 * @param ovp - OVP section of manifest, to be updated
 */
function createCard(key, ovp) {
    if (!ovp.cards) {
        ovp.cards = {};
    }
    if (!(key in ovp.cards)) {
        ovp.cards[key] = {};
    }
}
/**
 * Recursive function that searches for next avaialble id by increasing number by 1.
 * @param {boolean} sectionIds All ids in use.
 * @param {string} candidateId Candidate id to check if it is available.
 * @return {string} Id string.
 */
function findAvailableId(sectionIds, candidateId) {
    if (sectionIds.includes(candidateId)) {
        const idParts = candidateId.split('|');
        if (idParts.length === 3) {
            idParts.push('1');
        }
        else {
            idParts[3] = (parseInt(idParts[3]) + 1).toString();
        }
        return findAvailableId(sectionIds, idParts.join('|'));
    }
    return candidateId;
}
/**
 * Private recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configObject - current object to traverse
 * @param manifest - app descriptor (manifest.json)
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 */
function transferManifestEntriesOVP(configObject, manifest, exportResults, jsonSchema, targetDefinition, pathHierarchy) {
    if (targetDefinition) {
        if (targetDefinition['properties']) {
            processProperties(configObject, manifest, exportResults, jsonSchema, targetDefinition['properties'], pathHierarchy);
        }
        else if (targetDefinition['additionalProperties']) {
            processProperties(configObject, manifest, exportResults, jsonSchema, targetDefinition['additionalProperties'], pathHierarchy);
        }
    }
}
/**
 * Recursive function that transfers the content of a list of properties of a configuration to the overall exportResults
 * @param configObject - the given part of the configuration
 * @param manifest - manifest.json of the app
 * @param exportResults - overall result list, to be updated
 * @param jsonSchema - app-specific JSOn schema
 * @param propertyList - current property list of the config (properties or additional properties)
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 */
function processProperties(configObject, manifest, exportResults, jsonSchema, propertyList, pathHierarchy) {
    let currentObject;
    for (const key in propertyList) {
        currentObject = configObject[key];
        const exportPropertyRule = decorators_1.getExportRuleMetadata(configObject, key);
        if (exportPropertyRule) {
            if (exportPropertyRule.manifest) {
                const path = exportPropertyRule.manifest.path([...pathHierarchy, key]);
                const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
                if (key in v2_1.CardSettingsType) {
                    manifestSection['settings'] = currentObject ? currentObject : {};
                }
                else {
                    if (currentObject !== undefined) {
                        manifestSection[key] = currentObject;
                    }
                    else if (manifestSection[key]) {
                        delete manifestSection[key];
                    }
                }
            }
        }
        if (currentObject && typeof currentObject === 'object' && propertyList[key]) {
            if (key === 'cards') {
                //inserts and updates:
                Object.keys(currentObject).forEach((newKey) => {
                    const cardType = currentObject[newKey].template;
                    switch (cardType) {
                        case Card_1.CardTemplateType.list:
                            currentObject[newKey] = Object.assign(new controls_1.ListCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.stack:
                            currentObject[newKey] = Object.assign(new controls_1.StackCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.linklist:
                            currentObject[newKey] = Object.assign(new controls_1.LinklistCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.table:
                            currentObject[newKey] = Object.assign(new controls_1.TableCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.analytical:
                            currentObject[newKey] = Object.assign(new controls_1.AnalyticalCard(), currentObject[newKey]);
                            break;
                        default:
                            currentObject[newKey] = Object.assign(new controls_1.CustomCard(), currentObject[newKey]);
                            break;
                    }
                    createCard(newKey, exportResults['manifest']['sap.ovp']);
                    let targetDefinition;
                    if (!Object.values(Card_1.CardTemplateType).includes(cardType)) {
                        targetDefinition = ['CustomCard'];
                    }
                    else {
                        targetDefinition = Object.keys(jsonSchema['definitions']).filter((definition) => jsonSchema['definitions'][definition].properties &&
                            jsonSchema['definitions'][definition].properties.template &&
                            jsonSchema['definitions'][definition].properties.template.enum &&
                            jsonSchema['definitions'][definition].properties.template.enum[0] ===
                                currentObject[newKey].template);
                    }
                    transferManifestEntriesOVP(currentObject[newKey], manifest, exportResults, jsonSchema, jsonSchema['definitions'][targetDefinition[0]], [newKey]);
                });
                //check for deletions:
                Object.keys(manifest['sap.ovp'].cards).forEach((manifestCard) => {
                    if (!currentObject[manifestCard]) {
                        delete exportResults.manifest['sap.ovp'].cards[manifestCard];
                    }
                });
            }
            else if (propertyList[key].$ref) {
                const definitionArray = propertyList[key].$ref.split('#/definitions/');
                const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
                const cardSettingsType = key;
                switch (cardSettingsType) {
                    case v2_1.CardSettingsType.listCardSettings:
                        currentObject = Object.assign(new controls_1.ListCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.stackCardSettings:
                        currentObject = Object.assign(new controls_1.StackCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.linkListCardSettings:
                        currentObject = Object.assign(new controls_1.LinklistCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.tableCardSettings:
                        currentObject = Object.assign(new controls_1.TableCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.analyticalCardSettings:
                        currentObject = Object.assign(new controls_1.AnalyticalCard(), currentObject);
                        break;
                    default:
                        currentObject = Object.assign(new controls_1.CustomCard(), currentObject);
                        break;
                }
                transferManifestEntriesOVP(currentObject, manifest, exportResults, jsonSchema, nextTargetDefinition, [
                    ...pathHierarchy,
                    key
                ]);
            }
            else if (propertyList[key].anyOf) {
                processProperties(configObject, manifest, exportResults, jsonSchema, propertyList[key].anyOf, pathHierarchy);
            }
        }
    }
}
/**
 * Evaluates an export rule for a property or object, transfers to flex change or manifest setting
 * @param exportPropertyRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param baseId - selector id of the current page
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param key - key of the given property
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param fullManifest - old or existing manifest
 * @param pageKeys - array of keys to identify component in manifest
 * @param manifestSection - current manifest section
 */
function evaluateExportRule(exportPropertyRule, configObject, breadcrumbs, baseId, ids, title, key, exportResults, fullManifest, pageKeys, manifestSection) {
    let localBreadcrumbs;
    //eliminate subsections' hierarchy
    let index = breadcrumbs.indexOf('subsections');
    while (index > -1) {
        breadcrumbs.splice(index - 1, 2);
        index = breadcrumbs.indexOf('subsections');
    }
    if (exportPropertyRule.flex) {
        if (configObject !== undefined) {
            if (breadcrumbs.length === 0) {
                //only added on top = page level, do not forward
                localBreadcrumbs = ['page'];
            }
            else {
                localBreadcrumbs = breadcrumbs;
            }
            const flexChange = {
                controlId: exportPropertyRule.flex.controlId(baseId, ids, localBreadcrumbs, exportPropertyRule.flex.controlType, title),
                controlType: exportPropertyRule.flex.controlType(),
                content: {
                    property: key,
                    newValue: configObject
                }
            };
            exportResults.flexChanges.push(exportPropertyRule.flex.exportFunction(flexChange, fullManifest));
        }
    }
    else if (exportPropertyRule.manifest) {
        let path;
        if (breadcrumbs[0] === 'sections') {
            if (breadcrumbs[1] === 'custom') {
                path = exportPropertyRule.manifest.path(pageKeys, breadcrumbs[2]);
            }
            else {
                path = exportPropertyRule.manifest.path(pageKeys, breadcrumbs[1]);
                path = path.replace('/@', '::');
            }
        }
        else {
            path = exportPropertyRule.manifest.path(pageKeys);
        }
        manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
        const manifestKey = exportPropertyRule.manifest.key || key;
        if (configObject !== undefined) {
            const exportHandler = exportPropertyRule.manifest.export;
            if (exportHandler !== false) {
                if (exportHandler && typeof exportHandler === 'function') {
                    exportHandler(manifestSection, configObject);
                }
                else {
                    manifestSection[manifestKey] = configObject;
                }
            }
        }
        else {
            if (manifestSection[manifestKey]) {
                delete manifestSection[manifestKey];
            }
        }
        common_1.deleteEmptyStructure(exportResults.manifest, path);
    }
}
/**
 * Instantiates the export classes for the object page section
 * @param objectPageConfig - the given object page configuration
 * @param objectPage - the overall object page export class where the sections shall be included
 */
function getExportClassesForSections(objectPageConfig, objectPage) {
    /**
     * Instantiates the export classes for a single object page section
     * @param section - Export class as an object, to be updated
     * @param sectionId - Current section ID
     */
    function getClassesForSingleSection(section, sectionId) {
        if (section && section['table']) {
            const tableType = section['table'].type;
            switch (tableType) {
                case 'AnalyticalTable':
                    section['table'] = Object.assign(new controls_1.ObjectPageAnalyticalTable(), section['table']);
                    break;
                case 'GridTable':
                    section['table'] = Object.assign(new controls_1.ObjectPageGridTable(), section['table']);
                    break;
                case 'TreeTable':
                    section['table'] = Object.assign(new controls_1.ObjectPageTreeTable(), section['table']);
                    break;
                default:
                case 'ResponsiveTable':
                    section['table'] = Object.assign(new controls_1.ObjectPageResponsiveTable(), section['table']);
                    break;
            }
            if (section['table'].columns) {
                for (const columnId in section['table'].columns) {
                    section['table'].columns[columnId] = Object.assign(new controls_1.TableColumn(), section['table'].columns[columnId]);
                }
            }
        }
        else if (sectionId === 'custom' && Array.isArray(section)) {
            // Custom sections
            for (const index in section) {
                section[index] = Object.assign(section[index].className === v2_1.SAPUI5_FRAGMENT_CLASS
                    ? new controls_1.ObjectPageCustomSectionFragment()
                    : new controls_1.ObjectPageCustomSectionView(), section[index]);
            }
        }
    }
    /**
     * Recursive sub-function for handling subsections
     * @param section - Object page section in config
     */
    function getSubsectionClasses(section) {
        if (section['subsections']) {
            let subSection;
            for (const subSectionId in section['subsections']) {
                subSection = section['subsections'][subSectionId];
                getClassesForSingleSection(subSection, subSectionId);
                getSubsectionClasses(subSection);
            }
        }
    }
    // Main function
    let section;
    for (const sectionId in objectPageConfig.sections) {
        section = objectPage.sections[sectionId];
        getClassesForSingleSection(section, sectionId);
        getSubsectionClasses(section);
    }
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configSections - sections from configuration object
 * @param pageKey  - page key
 * @param fullManifest - full manifest object
 * @param parentIds - array of collected parent ids
 * @param manifest - app descriptor (manifest.json)
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param baseId - selector id of the current page
 * @param pageKeys - array of keys to identify component in manifest
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 */
function transferManifestExtensions(configSections, pageKey, fullManifest, parentIds, manifest, breadcrumbs, exportResults, appId, baseId, pageKeys, jsonSchema, targetDefinition) {
    const sectionIds = [];
    const entity = pageKey.split('|')[1];
    for (const section of configSections) {
        const id = findAvailableId(sectionIds, [section.relativePosition, entity, section.relatedFacet].join('|'));
        sectionIds.push(id);
    }
    for (const index in sectionIds) {
        const definition = targetDefinition['anyOf'].find((element) => element.$ref.includes(configSections[index].constructor.name));
        const definitionArray = definition.$ref.split('#/definitions/');
        const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
        transferManifestEntriesAndFlexChange(fullManifest, configSections[index], parentIds, manifest, [...breadcrumbs, sectionIds[index]], exportResults, appId, baseId, pageKeys, jsonSchema, nextTargetDefinition);
    }
    // Delete removed manifest entries
    const manifestSections = manifest_1.getManifestSectionByPathV2(exportResults.manifest, application_1.getViewExtensionsPath());
    for (const key in manifestSections) {
        if (!sectionIds.includes(key)) {
            delete manifestSections[key];
        }
    }
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configObject - current (sub)object of the configuration file
 * @param parentIds - array of collected parent ids
 * @param manifest - app descriptor (manifest.json)
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param baseId - selector id of the current page
 * @param pageKeys - array of keys to identify component in manifest
 * @param jsonSchema - application specific schema
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param title - title from the app schema (comprising for instance the facet ID)
 */
function transferManifestEntriesAndFlexChange(fullManifest, configObject, parentIds, manifest, breadcrumbs, exportResults, appId, baseId, pageKeys, jsonSchema, schemaDefinition, title) {
    let manifestSection, currentConfigObject;
    if (schemaDefinition && schemaDefinition['properties']) {
        for (const key in schemaDefinition['properties']) {
            currentConfigObject = configObject[key];
            const childId = decorators_1.getChildId(configObject, key);
            const ids = childId ? [...parentIds, childId] : parentIds;
            const exportPropertyRule = decorators_1.getExportRuleMetadata(configObject, key);
            if (exportPropertyRule) {
                evaluateExportRule(exportPropertyRule, currentConfigObject, breadcrumbs, baseId, ids, title, key, exportResults, fullManifest, pageKeys, manifestSection);
                continue;
            }
            const propertyDefinition = schemaDefinition['properties'][key];
            if (typeof currentConfigObject === 'object' &&
                Object.keys(currentConfigObject).length > 0 &&
                propertyDefinition) {
                let definitionArray;
                if (propertyDefinition.$ref) {
                    definitionArray = propertyDefinition.$ref.split('#/definitions/');
                }
                else if (propertyDefinition['anyOf']) {
                    definitionArray = propertyDefinition['anyOf'][0].$ref.split('#/definitions/');
                    const definition = propertyDefinition['anyOf'].find((element) => element.$ref.includes(currentConfigObject.constructor.name));
                    definitionArray = definition ? [...definition.$ref.split('#/definitions/')] : definitionArray;
                }
                else if (propertyDefinition.type === 'array' &&
                    (breadcrumbs[0] === 'sections' || breadcrumbs[0] === 'subsections') &&
                    key === 'custom') {
                    transferManifestExtensions(configObject[key], pageKeys[pageKeys.length - 1], fullManifest, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, propertyDefinition.items);
                    continue;
                }
                let nextTargetDefinition, nextTitle, nextConfigObject;
                if (definitionArray) {
                    nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
                    nextTitle = nextTargetDefinition['title'] ? nextTargetDefinition['title'] : title;
                    nextConfigObject = currentConfigObject;
                }
                else {
                    //e.g. sections ==> loop over all properties = subsections or other
                    nextTargetDefinition = propertyDefinition;
                    nextTitle = nextTargetDefinition['title'] ? nextTargetDefinition['title'] : key;
                    nextConfigObject = currentConfigObject;
                }
                transferManifestEntriesAndFlexChange(fullManifest, nextConfigObject, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, nextTargetDefinition, nextTitle);
            }
        }
    }
}
/**
 * Run through the given ListReport config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param listReportConfig - content of the src/ListReport_<entity_set>.json file
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportListReportPage = (appId, listReportConfig, entitySet, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    exportResults.flexChanges = [];
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    const listReport = Object.assign(new pages_1.ListReport(), listReportConfig);
    if (!listReport.table) {
        listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
    }
    if (listReport.table) {
        switch (listReport.table.type) {
            case v2_1.TableTypeV2.ResponsiveTable:
                listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.TreeTable:
                listReport.table = Object.assign(new controls_1.TreeTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.AnalyticalTable:
                listReport.table = Object.assign(new controls_1.AnalyticalTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.GridTable:
                listReport.table = Object.assign(new controls_1.GridTable(), listReport.table);
                break;
            default:
                listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
                break;
        }
        if (listReport.table.columns) {
            const complexIdMatch = new RegExp('DataField.+:::sSmartTableId::listReport.+');
            for (let columnId in listReport.table.columns) {
                if (complexIdMatch.exec(columnId) !== null) {
                    //This part was stripped off during import (table.ts)
                    columnId = 'template:::TableColumn:::' + columnId;
                }
                listReport.table.columns[columnId] = Object.assign(new controls_1.TableColumn(), listReport.table.columns[columnId]);
            }
        }
    }
    listReport.filterBar = Object.assign(new controls_1.FilterBar(), listReport.filterBar);
    const pageLayoutInformation = decorators_1.getPageLayoutInformation(listReport);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    const v2Page = utils_1.findListReportPage(manifest['sap.ui.generic.app'].pages, pageKeys);
    if (!v2Page.component.settings) {
        v2Page.component.settings = {};
    }
    exportResults.manifest = manifest;
    transferManifestEntriesAndFlexChange(JSON.parse(JSON.stringify(manifest)), listReport, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given AnalyticalListPage config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param analyticalListPageConfig - content of the src/AnalyticalListPage_<entity_set>.json file
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportAnalyticalListPage = (appId, analyticalListPageConfig, entitySet, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    exportResults.flexChanges = [];
    const analyticalListPage = Object.assign(new pages_1.AnalyticalListPage(), analyticalListPageConfig);
    const complexIdMatch = new RegExp('DataField.+:::sSmartTableId::analyticalListPage.+');
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    // find a better way to do this generically, perhaps using the schema?
    analyticalListPage.table = Object.assign(new controls_1.AnalyticalTable(), analyticalListPage.table);
    if (analyticalListPage.table && analyticalListPage.table.columns) {
        for (let columnId in analyticalListPage.table.columns) {
            if (complexIdMatch.exec(columnId) !== null) {
                //This part was stripped off during import (table.ts)
                columnId = 'template:::TableColumn:::' + columnId;
            }
            analyticalListPage.table.columns[columnId] = Object.assign(new controls_1.TableColumn(), analyticalListPage.table.columns[columnId]);
        }
    }
    analyticalListPage.filterBar = Object.assign(new controls_1.FilterBar(), analyticalListPage.filterBar);
    const pageLayoutInformation = decorators_1.getPageLayoutInformation(analyticalListPage);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    const v2Page = utils_1.findAnalyticalListPage(manifest['sap.ui.generic.app'].pages, pageKeys);
    v2Page.component.settings = {};
    exportResults.manifest = manifest;
    analyticalListPage.chart = Object.assign(new AnalyticalListPageChart_1.ChartSettings(), analyticalListPage.chart);
    transferManifestEntriesAndFlexChange(JSON.parse(JSON.stringify(manifest)), analyticalListPage, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given ObjectPage config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param objectPageConfig - content of the src/ObjectPage_<entity_set>.json file
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportObjectPage = (appId, objectPageConfig, entitySet, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    const objectPage = Object.assign(new pages_1.ObjectPage(), objectPageConfig);
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    // find a better way to do this generically, perhaps using the schema?
    objectPage.header = Object.assign(new controls_1.ObjectPageHeader(), objectPage.header);
    objectPage.layout = Object.assign(new controls_1.ObjectPageLayout(), objectPage.layout);
    const pageLayoutInformation = decorators_1.getPageLayoutInformation(objectPage);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    exportResults.manifest = manifest;
    const pageKeys = [];
    const v2Page = utils_1.findObjectPage(manifest['sap.ui.generic.app'].pages, entitySet, pageKeys);
    if (!v2Page) {
        return exportResults;
    }
    if (!v2Page.component.settings) {
        v2Page.component.settings = {};
    }
    if (objectPageConfig && objectPageConfig.sections) {
        getExportClassesForSections(objectPageConfig, objectPage);
    }
    transferManifestEntriesAndFlexChange(JSON.parse(JSON.stringify(manifest)), objectPage, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given ObjectPage config and return respective manifest entry and flex changes
 * @param overviewPageConfig - content of the src/OverviewPage_<entity_set>.json file
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportOverviewPage = (overviewPageConfig, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    const overviewPage = Object.assign(new pages_1.OverviewPage(), overviewPageConfig);
    overviewPage.cards = Object.assign(new controls_1.CustomCard(), overviewPage.cards);
    exportResults.manifest = manifest;
    transferManifestEntriesOVP(overviewPage, manifest, exportResults, jsonSchema, jsonSchema, []);
    return exportResults;
};
/**
 * Exports a Fiori Element V2 page.
 * It converts the entries of the input page (config file) to corresponding manifest settings and flex changes
 * @param appId - application id
 * @param page - content of the config file of a page
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportPageV2 = (appId, page, manifest, jsonSchema) => {
    switch (page.pageType) {
        case page_1.PageType.ListReport: {
            return exports.exportListReportPage(appId, page.config, page.entitySet, manifest, jsonSchema);
        }
        case page_1.PageType.ObjectPage: {
            return exports.exportObjectPage(appId, page.config, page.entitySet, manifest, jsonSchema);
        }
        case page_1.PageType.OverviewPage: {
            return exports.exportOverviewPage(page.config, manifest, jsonSchema);
        }
        case page_1.PageType.AnalyticalListPage: {
            return exports.exportAnalyticalListPage(appId, page.config, page.entitySet, manifest, jsonSchema);
        }
    }
};
/**
 * Exports a Fiori Element V2 application.
 * It converts the entries of the input application (config file) to corresponding manifest settings and flex changes
 * @param application - content of the config file of an application
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportApplicationV2 = (application, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    exportResults.manifest = manifest;
    const applicationV2 = Object.assign(new application_1.ApplicationV2(), application);
    //transfer application settings
    applicationV2.settings = Object.assign(new application_1.AppSettings(), application['settings']);
    for (const key in jsonSchema['definitions']['AppSettings']['properties']) {
        const exportPropertyRule = decorators_1.getExportRuleMetadata(applicationV2.settings, key);
        if (exportPropertyRule && exportPropertyRule.manifest) {
            const path = exportPropertyRule.manifest.path();
            const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
            if (application['settings'] && application['settings'][key] !== undefined) {
                manifestSection[key] = application['settings'][key];
            }
            else {
                delete manifestSection[key];
            }
        }
    }
    // transfer pages and routings
    const manifestPages = exportResults.manifest['sap.ui.generic.app'] && exportResults.manifest['sap.ui.generic.app'].pages;
    if (manifestPages && application['pages']) {
        manifest_1.transformPageToNewManifestV2(application.home, application['pages'], Object.values(manifestPages)[0]);
    }
    return exportResults;
};
//# sourceMappingURL=export.js.map