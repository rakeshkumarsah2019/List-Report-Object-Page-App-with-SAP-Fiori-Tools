"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const child_process_1 = require("child_process");
const crypto_1 = require("crypto");
const tempDir = require("temp-dir");
const mta = require("./mta");
exports.mta = mta;
const MTA_BIN = "mta";
const tempFileName = "temp.mta.yaml";
const mtaFileName = "mta.yaml";
async function runProcess(command, args) {
    return new Promise((resolve, reject) => {
        const proc = child_process_1.spawn(command, args);
        procEvents(proc, resolve, reject);
    });
}
function procEvents(proc, resolve, reject) {
    const output = [];
    let handled = false;
    proc.stdout.on("data", (data) => {
        output.push(String(data));
    });
    proc.stderr.on("data", (data) => {
        output.push(String(data));
    });
    proc.on("error", (err) => {
        if (handled) {
            return;
        }
        handled = true;
        reject(err);
    });
    proc.on("exit", (code) => {
        /* istanbul ignore if */
        if (handled) {
            return;
        }
        handled = true;
        const allOutput = output.join("").trim();
        let returnValue = allOutput.substring(allOutput.lastIndexOf("\n") + 1);
        // If the last line doesn't start with an opening curly brace \"{\", it isn't a JSON object as expected,
        // so instead, all the output is taken.
        /* istanbul ignore if */
        if (!returnValue.startsWith("{")) {
            returnValue = allOutput;
        }
        if (code === 0) {
            resolve(returnValue);
        }
        else {
            try {
                // Tries to get the error message. If no message is found, uses the return value itself.
                returnValue = JSON.parse(returnValue).message || returnValue;
            }
            catch (e) {
                // Ignores this and uses the return value itself.
            }
            reject(new Error(returnValue));
        }
    });
}
function parseOutput(output) {
    try {
        return JSON.parse(output);
    }
    catch (e) {
        /* istanbul ignore next */
        throw new Error(`Not a valid JSON output: ${output}\n${e.message}`);
    }
}
class Mta {
    constructor(mtaDirPath) {
        this.mtaPath = mtaDirPath;
        const hash = crypto_1.createHash("md5").update(this.mtaPath).digest("hex");
        this.mtaTempFilePath = path_1.join(tempDir, hash + "." + tempFileName);
        this.mtaFilePath = path_1.join(this.mtaPath, mtaFileName);
    }
    /**
     * Creates a new MTA:
     * Creates a new MTA project directory.
     * Creates a new "temp.mta.yaml" file in the new project directory.
     * Writes a descriptor for the "temp.mta.yaml" file.
     */
    async create(descriptor) {
        await this.clean();
        const output = await runProcess(MTA_BIN, ["create", "-p", this.mtaTempFilePath, "-d", JSON.stringify(descriptor)]);
        this.hashcode = parseOutput(output).hashcode;
    }
    /**
     * Gets the MTA file path;
     * if the MTA file path doesn't exist, an error message is displayed.
     */
    async getMtaFilePath() {
        if (fs_1.existsSync(this.mtaTempFilePath)) {
            return this.mtaTempFilePath;
        }
        else if (fs_1.existsSync(this.mtaFilePath)) {
            return this.mtaFilePath;
        }
        throw new Error("multitarget application not found");
    }
    /**
     *  Adds a new module.
     */
    async addModule(module, force = false) {
        const args = ["add", "module", "-d", JSON.stringify(module)];
        if (force) {
            args.push("-f");
        }
        await this.runOnTempFile(args);
    }
    /**
     *  Adds a new resource.
     */
    async addResource(resource, force = false) {
        const args = ["add", "resource", "-d", JSON.stringify(resource)];
        if (force) {
            args.push("-f");
        }
        await this.runOnTempFile(args);
    }
    /**
     *  Gets all modules.
     */
    async getModules() {
        return await this.runOnExistingFile(["get", "modules"]);
    }
    /**
     * Gets all resources
     */
    async getResources() {
        return await this.runOnExistingFile(["get", "resources"]);
    }
    /**
     * Updates an existing module.
     */
    async updateModule(module) {
        await this.runOnTempFile(["update", "module", "-d", JSON.stringify(module)]);
    }
    /**
     * Updates an existing resource.
     */
    async updateResource(resource) {
        await this.runOnTempFile(["update", "resource", "-d", JSON.stringify(resource)]);
    }
    /**
     * Updates the build parameters.
     * Updates the existing build parameters or adds new build parameters if they don't exist.
     */
    async updateBuildParameters(buildParameters, force = false) {
        const args = ["update", "buildParameters", "-d", JSON.stringify(buildParameters)];
        if (force) {
            args.push("-f");
        }
        await this.runOnTempFile(args);
    }
    /**
     * Checks if the name given exists in the "mta.yaml" file.
     * @param name
     */
    async doesNameExist(name) {
        return await this.runOnExistingFile(["exist", "-n", name]);
    }
    /**
     * Saves the "mta.yaml" file:
     * Copies the "temp.mta.yaml" file content to the "mta.yaml" file.
     * Deletes the "temp.mta.yaml" file.
     */
    async save() {
        const bExists = fs_1.existsSync(this.mtaTempFilePath);
        if (bExists) {
            const output = await runProcess(MTA_BIN, ["copy", "-s", this.mtaTempFilePath, "-t", this.mtaFilePath]);
            await runProcess(MTA_BIN, ["deleteFile", "-p", this.mtaTempFilePath]);
            this.hashcode = parseOutput(output).hashcode;
        }
    }
    /**
     * Deletes the temporary mta file.
     */
    async clean() {
        const bExists = fs_1.existsSync(this.mtaTempFilePath);
        if (bExists) {
            await runProcess(MTA_BIN, ["deleteFile", "-p", this.mtaTempFilePath]);
        }
    }
    /**
     * Runs the MTA command with the sent arguments and the additional argument `-p <temp file path>`.
     * Before running the MTA command, the function makes sure that the "temp.mta.yaml" exists
     * according to the following logic:
     * If the "temp.mta.yaml" file exists, runs the MTA command on it.
     * If the "temp.mta.yaml" file doesn't exist, checks if the "mta.yaml" file exists;
     * if not, displays an error message.
     * If the "mta.yaml" file exists, copies the "mta.yaml" file content to the "temp.mta.yaml" file
     * and then runs the MTA command on it.
     *
     * @param args - the arguments to send to the MTA executable.
     */
    async runOnTempFile(args) {
        args = args.concat(["-p", this.mtaTempFilePath]);
        let bExists = fs_1.existsSync(this.mtaTempFilePath);
        let output;
        if (!bExists) {
            bExists = fs_1.existsSync(this.mtaFilePath);
            if (!bExists) {
                throw new Error("Multi-target application not found");
            }
            output = await runProcess(MTA_BIN, ["copy", "-s", this.mtaFilePath, "-t", this.mtaTempFilePath]);
            this.hashcode = parseOutput(output).hashcode;
        }
        args = args.concat(["-c", this.hashcode || "0"]);
        output = await runProcess(MTA_BIN, args);
        const outputObj = parseOutput(output);
        this.hashcode = outputObj.hashcode;
        return outputObj.result;
    }
    async runOnExistingFile(args) {
        args = args.concat(["-p", await this.getMtaFilePath()]);
        const output = await runProcess(MTA_BIN, args);
        const outputObj = parseOutput(output);
        this.hashcode = outputObj.hashcode;
        return outputObj.result;
    }
}
exports.Mta = Mta;
exports.default = Mta;
//# sourceMappingURL=index.js.map